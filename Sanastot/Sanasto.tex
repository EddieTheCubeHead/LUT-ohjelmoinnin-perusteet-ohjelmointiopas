\newglossaryentry{abstraktio}
{
    name=abstraktio,
    description={(abstraction) Ohjelmoinnin perustekniikka, jossa ongelman
tarkka ratkaisu piilotetaan kutsuttavan koodirakenteen, kuten funktion, 
tietorakenteen tai luokan taakse}
}

\newglossaryentry{funktio}
{
    name=funktio,
    description={(function) Ohjelmoijan määrittelemä käskysarja, eli koodin
osa, joka on rajattu, ottaa tietyn määrän parametreja ja mahdollisesti
palauttaa paluuarvon. Tunnetaan olio-ohjelmoinnissa nimellä metodi},
    see={parametri,metodi}
}

\newglossaryentry{parametri}
{
    name=parametri,
    description={(parameter) Arvo, jonka funktio tai metodi ottaa muulta
koodilta vastaan},
    see={funktio,metodi}
}

\newglossaryentry{metodi}
{
    name=metodi,
    description={(method) Luokkaan sidottu käskysarja, joka suorittaa
ottamiensa parametrien ja luokan omien datakenttien perusteella jonkin tietyn
toiminnon},
    see={parametri,funktio,luokka}
}

\newglossaryentry{tietue}
{
    name=tietue,
    description={(struct) Vanhahko muokattava tietotyyppi, yleinen esimerkiksi
C-kielessä. Käyttäjä voi määritellä tietueen sisältämään mitä tahansa
vakiokokoisia datakenttiä. Luokkien edeltäjä}
}

\newglossaryentry{olio}
{
    name=olio,
    description={(object) Luokan instanssi. Yksittäinen koodissa luotu
toimija, joka sisältää datakenttiä ja metodeita. Luokka, jonka pohjalta olio
luodaan määrittää olion käytettävissä olevat metodit ja siihen
tallennetut datatyypit, mutta vain olio pääsee käsiksi omiin metodeihin
ja datakenttiinsä},
    see={luokka,metodi,instanssi}
}

\newglossaryentry{luokka}
{
    name=luokka,
    description={(class) Ohjelmoijan kirjoittama muotti, jonka pohjalta
ohjelmisto luo olioita. Voi sisältää metodeja ja datakenttiä mutta yleensä
näiden käyttämiseksi vaaditaan olion luontia},
    see={olio,metodi,instanssi}
}

\newglossaryentry{instanssi}
{
    name=instanssi,
    description={(instance) Olio, joka on luotu jonkin luokan pohjalta on
kyseisen luokan instanssi},
    see={olio,luokka}
}

\newglossaryentry{enkapsulaatio}
{
    name=enkapsulaatio,
    description={(encapsulation) Datan piilottaminen olion sisään niin ettei
muu ohjelmisto näe kyseistä dataa. Mitataan asteikolla matala-korkea, niin että
korkea enkapsulaatio tarkoittaa pientä määrää julkisia metodeja tai datakenttiä
ja matala taas suurta määrää julkisia metodeja ja datakenttiä}
    see={luokka,koheesio,metodi}
}

\newglossaryentry{rajapinta}
{
    name=rajapinta,
    description={(interface) Yleisessä käytössä termi ohjelmistossa toteutuvalle sopimukselle,
jonka jokin metodi, luokka tmv. toteuttaa tai kahden ohjelmiston osan välinen taso. Javan
yhteydessä luokka, joka luodaan interface-avainsanalla ja joka sisältää vain
luokan implementoimien metodien signatuurit. Rajapintaluokka ei yleensä sisällä ollenkaan
toiminnallista koodia},
    see={java:interface}
}

\newglossaryentry{koheesio}
{
    name=koheesio,
    description={(cohesion) Ohjelmiston laadun mittaamiseen käytetty käsite.
Mittaa luokkien sisäistä yhtenäisyyttä akselilla matala-korkea. Matala koheesio
tarkoittaa että luokassa on paljon metodeja jotka eivät keskustele toisten
luokan metodien kanssa ja matala että luokan kaikki metodit käyttävät useita
muita luokan metodeja. Matala koheesio on toivottavaa, koska luokan tehtävä
on tehdä yksi ja vain yksi asia}
}

\newglossaryentry{pariutuminen}
{
    name=pariutuminen,
    description={(coupling) Ohjelman laadun mittaamiseen käytetty käsite.
Mittaa luokkien keskenäisten riippuvuuksien määrää akselilla löysä-tiukka.
Löysässä pariutumisessa ohjelmiston luokkien väliset riippuvuudet ovat
harvassa, jolloin ohjelmiston muokkaaminen on helppoa. Tiukassa pariutumisessa
puolestaan jokaisella ohjelmiston luokalla on riippuvuus moneen muuhun
ohjelmiston luokkaan, jolloin ohjelmison muokkaus hankaloituu ja täten voidaan
katsoa ohjelmiston laadun laskevan}
}

\newglossaryentry{primitiivinen tietotyyppi}{
    name=primitiivinen tietotyyppi,
    description={(primitive data type) Tietotyyppi, jonka ohjelmointikieli
kykenee säilömään suoraan muistipaikkaan raakana numeerisena datana. Ainoat
tietotyypit Javassa, jotka eivät ole jonkin luokan instansseja},
    see={luokka,instanssi}
}

\newglossaryentry{nakyvyysmaare}
{
    name=näkyvyysmääre,
    description={(access modifier) Muuttujan näkyvyyden määrittävä avainsana},
    see=muuttuja
}

\newglossaryentry{muuttuja}
{
    name=muuttuja,
    description={(variable) koodissa määritelty tietokenttä, joka sisältää jonkin ohjelman
käyttämän arvon}
}

\newglossaryentry{staattinen kieli}
{
    name=staattisesti tyypitetty kieli,
    description={(statically typed language) Ohjelmointikieli, joka tietää jokaisen koodissa
esiintyvän muuttujan tietotyypin koko ajan}
}

\newglossaryentry{signatuuri}
{
	name=signatuuri,
	description={(signature) Metodin määritelmä, joka sisältää sekä metodin nimen, että sen
ottamien argumenttien tyypit}
}

\newglossaryentry{noutaja}
{
	name=noutaja,
	description={(getter) Metodi, jonka tehtävänä on tarjota rajoitettu saatavuus johonkin
luokan yksityiseen muuttujan. Ei yleensä ota argumentteja ja palauttaa luokan omistaman toivotun
muuttujan. Nimetään camelCase-tyylillä sijoittamalla muuttujan nimen eteen "get" ("getVariable").
Parantaa enkapsulaatiota ja mahdollistaa esimerkiksi laiskan alustuksen muuttujille}
}

\newglossaryentry{asettaja}
{
	name=asettaja,
	description={(setter) Metodi, jonka tehtävänä on tarjota luokan ulkopuolisille toimijoille
mahdollisuus asettaa arvoja luokan yksityiseen muuttujaan. Ottaa yleensä arvoksi muuttujan toivotun
arvon, eikä palauta mitään. Nimetään camelCase-tyylillä sijoittamalla muuttujan nimen eteen "set"
("setVariable"). Parantaa enkapsulaatiota ja mahdollistaa esimerkiksi uusien arvojen validoinnin
ennen niiden asettamista}
}

\newglossaryentry{rakentaja}
{
	name=rakentaja,
	description={(constructor) Luokkametodi, joka määritellään ja kutsutaan luokan nimellä ja nimensä
mukaisesti rakentaa ja palauttaa uuden luokan instanssin},
	see={luokkametodi,instanssi,java:new}
}

\newglossaryentry{luokkametodi}
{
	name=luokkametodi,
	description={(class method) Metodi, joka on luokan instanssin sijaan sidottu itse luokkaan.
Ei voida käyttää instanssiin sidottuja muuttujia, mutta voi käyttää luokkamuuttujia. Määritellään
yleensä static-avainsanalla ja kutsutaan luokan nimen pistenotaatiolla},
	see={luokkamuuttuja,java:static}
}

\newglossaryentry{luokkamuuttuja}
{
	name=luokkamuuttuja,
	description={(class variable) Muuttuja, joka on luokan instanssin sijaan sidottu itse luokkaan.
Muokattavissa ja tarkasteltavissa jokaisesta luokan instanssista jaetusti. Määritellään yleensä
static-avainsanalla},
	see=java:static
}

\newglossaryentry{taulukko}
{
	name=taulukko,
	description={(array) Tietorakenne, jossa yksittäiset alkiot on säilötty vierekkäisiin
muistipaikkoihin. Vie vähän muistitilaa ja mahdollistaa nopeat haut ja lisäykset jos alkion
indeksi on tiedossa etukäteen. Yleensä taulukon koko on määriteltävä sen luomisen yhteydessä,
tämä on totta myös Javassa. Javassa taulukko luodaan new-avainsanalla lisäämällä taulukon
säilömän tietotyypin perään hakasulkeet, joiden sisään suljetaan taulukon koon määrittelevä
numero. Taulukkotyyppinen muuttuja määritellään lisäämällä muuttujan tietotyypin määritelmän
perään hakasulkeet. Tällöin esimerkiksi int-tyypin kymmenen alkion taulukko, joka on säilötty
"intArray"-muuttujaan määriteltäisiin seuraavasti:\newline{} "int[] intArray = new int[10]"}
}

\newglossaryentry{geneerinen luokka}
{
	name=geneerinen luokka,
	description={(generic class) Luokan ominaisuus, joka määrittää luokan instanssien täyden
tyyppisignatuurin olevan riippuvainen toisesta luokasta. Tämä toinen luokka voidaan määrittää
jokaisen luokan instanssin kohdalla erikseen pienempi kuin- ja suurempi kuin -merkkien väliin
suljetulla notaatiolla. Esimerkiksi kokoelmat tarvitsevat tietoa sisältämiensä olioiden
tyypityksestä. Merkkijonoja sisältävä ArrayList-kokoelma voitaisiin siis luoda seuraavalla 
notaatiolla:\newline{}"new ArrayList<String>()"\newline{}Geneerinen luokka voi olla myös geneerinen useamman luokan suhteen, jolloin luokat erotetaan pilkulla tai riippuvainen toisesta
geneerisestä luokasta, jolloin geneerisyyden notaatiot kirjoitetaan
sisäkkäin:\newline{}"new HashMap<String, ArrayList<Int>>()"},
	see={java:ArrayList,java:HashMap}
}

\newglossaryentry{hajautustaulu}
{
	name=hajautustaulu,
	description={(hash table) Tietorakenne, joka koostuu avain-arvo -pareista. Jokaista avainta
vastaa yksi arvo. Arvot ovat noudettavissa nopeasti avaimen perusteella. Toteutettu Javan
standardikirjaston HashMap-luokassa},
	see={java:HashMap}
}

\newglossaryentry{ajonaikainen kaantaminen}
{
	name=ajonaikainen kaantaminen,
	description={(Just-In-Time compiling, JIT) Ajonaikainen kääntäminen on koodin ajotekniikka,
jossa}
}


\newglossaryentry{kaannetty kieli}
{
	name=kaannetty kieli,
	description={(compiled language) Ohjelmointikieli, jossa ohjelmistot kompiloidaan ennen
ajamista ja ohjelman ajaminen tapahtuu suorittamalla kompilointiprosessin tuottama tiedosto.
Esimerkiksi c ja Rust ovat kompiloituja kieliä}
}


\newglossaryentry{tulkattu kieli}
{
	name=tulkattu kieli,
	description={(intrepeted language) Ohjelmointikieli, joka ajetaan lukemalla kooditiedostot
reaaliajassa. Esimerkiksi Python ja JavaScript ovat tulkattavia kieliä}
}

\newglossaryentry{roskankeruu}
{
	name=roskankeruu,
	description={(garbage collection) Muistinhallinnan tekniikka, jossa ohjelma tietyin väliajoin
ajaa aliohjelman, joka käy läpi kaikki muuttujat muistissa, tarkistaa onko niihin olemassa
viittauksia ja poistaa muuttujat, joilla ei ole enää aktiivista viittausta}
}

\newglossaryentry{ylikuormitus}
{
	name=ylikuormitus,
	description={(overloading) Kahden samannimisen metodin määrittäminen eri argumenteilla.
Argumenttejä voi olla sama määrä, mutta eri tyypeillä, tai eri määrä. Java hakee metodikutsun
yhteydessä automaattisesti kutsuttua signatuuria vastaavan version ylikuormitetusta metodista}
}

\newglossaryentry{pakotettu tyypinmuunnos}
{
	name=pakotettu tyypinmuunnos,
	description={(casting) Operaatio, jossa muuttujan tyyppi yritetään manuaalisesti muuttaa
joksikin toiseksi tyypiksi. Voi epäonnistua. Tapahtuu kirjoittamalla toivottu tietotyyppi
muutettavan muuttujan nimen eteen sulkuihin. Esimerkiksi double-tyypin muuttuja "doubleNumber"
voitaisiin säilöä int-tyypin muuttujaan "intNumber" pakotetun tyyppimuunnoksen avulla seuraavalla
koodinpätkällä:\newline{}"int intNumber = (int)doubleNumber"}
}

\newglossaryentry{lueteltu tyyppi}
{
	name=lueteltu tyyppi,
	description={(enumerated type) Ohjelmoijan määrittelemä tyyppi, joka koostuu rajatusta
arvojoukosta. Jokaisella arvojoukon arvolla on nimi, jolla siihen viitataan koodissa. Ohjelma
käsittelee kuitenkin arvoja kokonaislukuina, nopeuttaen ajamista. Javassa lueteltu tyyppi luodaan
enum-avainsanalla},
	see={java:enum}
}

\newglossaryentry{serialisaatio}
{
	name=serialisaatio,
	description={(serialization) Erityisesti olio-ohjelmoinnissa yleinen ohjelmointikielten
ominaisuus, joka mahdollistaa olioiden esittämisen tekstimuotoisena datana. Tällä tavalla
esitettyjä olioita on helpompi käsitellä esimerkiksi tiedostojenhallinnan yhteydessä tai
verkkoliikenteessä}
}

\newglossaryentry{periytyminen}
{
	name=periytyminen,
	description={(inheritance) Olio-ohjelmoinnin konsepti, jossa luokat voivat periä toisen luokan
ominaisuudet. Luokkaa, joka perii toisen luokan kutsutaan lapsiluokaksi ja luokkaa, jolla on
lapsiluokka kantaluokaksi. Lapsiluokka sisältää automaattisesti kaikki kantaluokan kentät, eli
muuttujat ja metodit, joiden näkyvyysmääre on protected tai laajempi. Kenttiä voidaan tarvittaessa
ylikirjoittaa},
	see={lapsiluokka,kantaluokka,näkyvyysmääre,java:protected,java:extends}
}

\newglossaryentry{lapsiluokka}
{
	name=lapsiluokka,
	description={(child class) Luokka, joka perii toisen luokan},
	see={periytyminen,kantaluokka}
}

\newglossaryentry{kantaluokka}
{
	name=kantaluokka,
	description={(parent class) Luokka, josta on periytetty vähintään yksi toinen luokka},
	see={periytyminen,lapsiluokka}
}

\newglossaryentry{UML}
{
	name=UML,
	description={(Unified Modelin Language) Mallinnustekniikka ohjelmistojen rakenteen esittelyyn.
UML-standardi sisältää monia erilaisia kaavioita, mutta olio-ohjelmoinnin kannalta niistä tärkein
on luokkakaavio. Muita tärkeitä kaavioita ovat oliokaavio, tilakaavio ja sekvenssikaavio},
	see=luokkakaavio
}

\newglossaryentry{luokkakaavio}
{	
	name=luokkakaavio,
	description={(class diagram) UML-standardin kaavio, joka kuvaa luokkien välisiä suhteita
ohjelmistossa. Koostuu luokkia esittävistä yleensä neliön muotosista soluista. Solut sisältävät
luokkien tietokentät ja metodit. Luokkia voidaan yhdistää toisiinsa erilaisilla nuolilla
osoittamaan niiden välisiä suhteita kuten periytymistä, kompositiota ja aggregaatiota},
	see={periytyminen,kompositio,aggregaatio}
}

\newglossaryentry{kompositio}
{
	name=kompositio,
	description={(composition) Luokkien suhteita kuvaava termi. Kompositiossa luokka B on sidottu
luokan A elinikään niin, että jokainen A:n instanssi sisältää vakiomäärän viittauksia B:n
instansseihin (yleensä 1). Kyseiset B:n instanssit luodaan yhdessä ne omistavan A:n instanssin
kanssa ja ne tuhotaan yhdessä ne omistavan A:n instanssin kanssa. Kompositiossa siis luokka B on
riippuvainen luokasta A olemassaolonsa ajan}
}

\newglossaryentry{aggregaatio}
{
	name=aggregaatio,
	description={(aggregation) Luokkien suhteita kuvaava termi. Aggregaatiossa luokka A omistaa
viittauksen luokan B instanssiin, mutta tämän instanssin luonti ja tuhoutuminen ei ole sidottu
luokan A elinkaareen. Esimerkiksi aktiivisia pelaajia säilövän peli-luokan suhde pelaaja-luokkaan
on aggregaatio, mikäli pelaajat säilötään peli-luokan sisällä listassa, johon jo olemassa oleva
pelaaja lisätään tämän liittyessä peliin ja josta pelaaja poistetaan tämän poistuessa pelistä}
}

\newglossaryentry{korvaaminen}
{
	name=korvaaminen,
	description={(overriding) Lapsiluokan perimän metodin toiminnallisuuden uudelleen määrittely.
Tapahtuu määrittelemällä lapsiluokassa metodin, jonka signatuuri on identtinen kantaluokan
korvattavan metodin kanssa. Tämän metodin toiminnallisuus ajetaan kantaluokan metodin sijaan},
	see={periytyminen,signatuuri,kantaluokka,lapsiluokka}
}

\newglossaryentry{SOLID-periaatteet}
{
	name=SOLID-periaatteet,
	description={(SOLID-principles) Viisi oliopohjaisen ohjelmoinnin käyttöön kehitettyä
periaatetta, joiden tavoitteena on auttaa laadukkaan, siistin, helposti laajennettavan ja helposti
luettavan oliopohjaisen ohjelmiston tuottamisessa. Periaatteet ovat "yhden vastuun periaate"
(Single Responsibility Principle - SRP), "avoin/suljettu-periaate" (Open/Closed Principle - OCP),
"Liskovin korvaavuusperiaate" (Liskov Substitution Principle - LSP), "rajapintojen erottelu
-periaate" (Interface Segregation Principle - ISP) ja "käänteisten riippuvuuksien periaate"
(Dependency Injection Principle - DIP)},
	see={yhden vastuun periaate,  avoin/suljettu-periaate, Liskovin korvaavuusperiaate, 
	rajapintojen erottelu -periaate, kaanteisten riippuvuuksein periaate}
}

\newglossaryentry{yhden vastuun periaate}
{
	name=yhden vastuun periaate,
	description={(Single Responsibility Principle - SRP) SOLID-periaatteisiin kuuluva sääntö, joka
käsittelee koodin jakamista luokkiin. Periaatteen mukaan jokaisella luokalla pitäisi olla yksi ja
vain yksi vastuu. Esimerkiksi String-luokan vastuu on vain merkkijonotyyppisen datan säilöminen ja
sen vastuisiin ei kuulu esimerkiksi datan esittäminen},
	see={SOLID-periaatteet}
}

\newglossaryentry{avoin/suljettu-periaate}
{
	name=avoin/suljettu-periaate,
	description={(Open/Closed Principle - OCP) SOLID-periaatteisiin kuuluva sääntö, jonka mukaan
kirjoitetun koodin on oltava suljettu muutoksilta, mutta avoin laajennukselle. Ohjelmiston osien
on säännön mukaan tapa laajentaa toimintaansa muokkaamatta olemassaolevaa toiminnan määrittelevää
koodia. Esimerkiksi mikäli ohjelmisto käyttää switch-rakennetta, jonka sisällä suoritetaan
logiikkaa saapuvan olion tyypin mukaan, ei rakenne ole laajennettavissa toiminnallisuudeltaan,
ilman että rakenteen koodia muokataan. Sen sijaan rakenne, joka on ohjelmoitu vastaanottamaan
olio ja kutsumaan oliossa itsessään määriteltyä metodia on laajennettavissa toiminnallisuudeltaan
muokkaamatta lähdekoodia. Tämä tapahtuu tarjoamalla rakenteelle erilainen olio, joka toteuttaa
rajapinnan, jossa rakenteen kutsuma metodi on määritelty},
	see={SOLID-periaatteet}
}

\newglossaryentry{Liskovin korvaavuusperiaate}
{
	name=Liskovin korvaavuusperiaate,
	description={(Liskov Substitution Principle - LSP) SOLID-periaatteisiin kuuluva sääntö, joka
käsittelee kanta- ja lapsiluokkien suhdetta. Liskovin korvaavuussäännön mukaan, lapsiluokan
instanssia pitää pystyä käsittelemään kuin kantaluokan instanssia, eli sen on paljastettava
vähintään samat metodit ja muuttuvat kuin kantaluokan instanssien. Korvaavuus ei kulje molempiin
suuntiin, vaan lapsiluokan instanssit saavat säännön mukaan sisältää metodeja ja muuttujia, joita
kantaluokan instansseista ei löydy},
	see={SOLID-periaatteet,kantaluokka,lapsiluokka,periytyminen}
}

\newglossaryentry{rajapintojen erottelu -periaate}
{
	name=rajapintojen erottelu -periaate,
	description={(Interface Segregation Principle - ISP) SOLID-periaatteisiin kuuluva sääntö, joka
käsittelee rajapintojen toiminnallisuuksien rajaamista. Periaatteen mukaan rajapinnan
implementoivan luokan ei pitäisi joutua määrittelemään metodeja, joita se ei tarvitse. Käytännössä
siis jokainen rajapinta pitäisi suunnitella tarpeeksi pieneksi, jotta kaikki sen implementoivat
luokat käyttävät kaikkia sen metodeja}
	see={SOLID-periaatteet,rajapinta,java:interface}
}

\newglossaryentry{kaanteisten riippuvuuksien periaate}
{
	name=kaanteisten riippuvuuksien periaate,
	description={(Dependency Inversion Principle -DIP) SOLID-periaatteisiin kuuluva sääntö, joka
käsittelee ohjelmiston riippuvuuksien suuntaa. Periaatteen mukaan ohjelmiston korkean tason
kompinenttien ei pitäisi olla riippuvaisia matalan tason komponenteista vaan molempien olisi
oltava riippuvainen jaetusta abstraktiosta (toteutettu rajapintaluokkana). Samaan tapaan
rajapintaluokkien ei tulisi olla riippuvaisia konkreettisista luokista, vaan konkreettisten 
luokkien tulisi aina olla riippuvaisia rajapintaluokista},
	see={SOLID-periaatteet,rajapinta,java:import}
}

\newglossaryentry{abstrakti luokka}
{
	name=abstrakti luokka,
	description={(abstract class) Luokka, joka on määritelty abstract-avainsanalla ja jolle on
määritelty vähintään yksi abstrakti metodi. Abstraktista luokasta ei voi luoda instanssia, vaan
luokkaa voi käyttää vain kantaluokkana luokasta luoduille konkreettisille luokille. Näiden
konkreettisten luokkien on implementoitava kaikki luokan abstraktit metodit},
	see={kantaluokka,periytyminen,java:abstract,abstrakti metodi,konkreettinen luokka}
}

\newglossaryentry{abstrakti metodi}
{
	name=abstrakti metodi,
	description={(abstract method) Metodi, joka on määritelty abstract-avainsanalla ja joka
sijaitsee abstraktissa luokassa. Abstraktin metodin määritelmä ei sisällä metodin runkoa,
ainoastaan signatuurin. Luokan konkreettisten lapsiluokkien on implementoitava kyseinen metodi},
	see={abstrakti luokka,signatuuri,java:abstract}
}

\newglossaryentry{konkreettinen luokka}
{
	name=konkreettinen luokka,
	description={(concrete class) Luokka, joka on abstraktin luokan lapsiluokka eikä ole itse
abstrakti luokka. Luokan on implementoitava kaikki kantaluokan abstraktit metodit},
	see={abstrakti luokka,abstrakti metodi}
}

\newglossaryentry{toteuttaa}
{
	name=toteuttaa,
	description={(implement) Rajapinnan toteuttaminen tarkoittaa, että jokin luokka tai metodi
toimii kuten jokin rajapintamääritelmä sanoo sen toimivan. Javassa puhutaan rajapintaluokan
toteuttamisesta käytettäessä implements avainsanaa luokan määritelmässä. Tällöin rajapinnan
toteuttavan luokan voi olettaa toimivan kuten rajapintaluokka määritää, eli luokkaa voidaan
käsitellä kuten toteutetun rajapintaluokan instanssia},
	see={rajapinta,luokka,java:implements}
}