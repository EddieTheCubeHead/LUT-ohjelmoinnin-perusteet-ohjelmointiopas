\documentclass{tufte-book}

\hypersetup{colorlinks}

%%
% Omat komennot
\newcommand{\lut}{Lappeenrannan-Lahden teknillinen yliopisto LUT }
\newcommand{\lutin}{Lappeenrannan-Lahden teknillisen yliopiston LUT:n }
\newcommand{\eng}[1]{\textit{(#1)}}
\newcommand{\new}[1]{\textit{\gls{#1}}}
\newcommand{\newnogls}[1]{\textit{#1}}
\newcommand{\neweng}[2]{\new{#1} \eng{#2}}
\newcommand{\newengnogls}[2]{\newnogls{#1} \eng{#2}}
\newcommand{\java}[1]{\underline{\gls{java:#1}}}
\newcommand{\javanogls}[1]{\underline{#1}}
\newcommand{\newjava}[1]{\textit{\java{#1}}}
\newcommand{\newjavanogls}[1]{\textit{\javanogls{#1}}}


%%
% Book metadata
\title{Ohjelmointiopas{\small \lutin olio-ohjelmointikurssi}\thanks{Kiitokset kandityön valvojalle
Erno Vanhalalle.}}
\author[Eetu Juhani Asikainen]{Eetu Juhani Asikainen}
\publisher{Lisää julkaisija?}

%%
% For nicely typeset tabular material
\usepackage{booktabs}

\usepackage[utf8]{inputenc}

%%
% Prints a trailing space in a smart way.
\usepackage{xspace}

% Prints the month name (e.g., January) and the year (e.g., 2008)
\newcommand{\monthyear}{
  \ifcase\month\or January\or February\or March\or April\or May\or June\or
  July\or August\or September\or October\or November\or
  December\fi\space\number\year
}

\usepackage{units}
\usepackage{graphicx}
\graphicspath{{./Kuvat/}}

% Generates the index
\usepackage{makeidx}
\makeindex

\usepackage[toc, automake]{glossaries}
\newglossary[jvg]{java}{jvd}{jvn}{Javan avainsanat}
\glsaddall
\makeglossaries

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Java code highlighting
\usepackage[utf8]{inputenc}
\usepackage{pygmentex}
\usepackage[cache=false]{minted} 
\usepackage{listings}
\renewcommand{\lstlistingname}{Koodiesimerkki}
\renewcommand{\lstlistlistingname}{Koodiesimerkit}

\newcommand{\code}[3]{
\begin{listing}
    \inputminted{java}{OhjelmointiopasEsimerkit/src/#1/#2.java}
    \caption{#3}
    \label{Java-#1-#2}
\end{listing}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% SANASTOT
\include{Sanastot/Sanasto}
\include{Sanastot/JavaAvainsanat}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

% Front matter
\frontmatter

\maketitle

\newpage
\begin{fullwidth}
~\vfill
\thispagestyle{empty}
\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}
Copyright \copyright\ \the\year\ \thanklessauthor

\par\smallcaps{Published by \thanklesspublisher}

\par\smallcaps{tufte-latex.googlecode.com}

\par Licensed under the Apache License, Version 2.0 (the ``License''); you may not
use this file except in compliance with the License. You may obtain a copy
of the License at \url{http://www.apache.org/licenses/LICENSE-2.0}. Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an \smallcaps{``AS IS'' BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND}, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.\index{license}

\par\textit{First printing, \monthyear}
\end{fullwidth}

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Oppaasta ja sen käytöstä}
\label{oppaasta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Esipuhe}
\label{esipuhe}

\newthought{Tämä opas} on kirjoitettu osaksi \lutin olio-ohjelmoinnin perusteiden kurssin
kurssimateriaaleja. Opas käy läpi koko kurssin  teoriasisällön lukuunottamatta Android-API:n
käyttöä. Opas on tarkoitettu käytettäväksi osana kurssikokonaisuutta, mutta se on suunniteltu
niin, että se tarjoaa laadukkaan perehdytyksen oliopohjaiseen ajatteluun, suunnitteluun ja
ohjelmointiin myös itsenäisenä kokonaisuutena.

\newthought{Oppaan tavoitteena} on tarjota opiskelijoille helppokäyttöinen,
laadukas ja suomenkielinen resurssi kurssin käsittelemien aihealueiden
opiskeluun. Opas olettaa käyttäjän hallitsevan proseduraalisen ohjelmoinnin
perusteet, jotka käydään läpi esimerkiksi \lutin "Ohjelmoinnin Perusteet" 
-kurssilla.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Oppaan rakenne}
\label{rakenteesta}

\newthought{Opas on jaettu} kahteentoista sisältölukuun ja kahteentoista bonuslukuun. Sisältöluvut
käsittelevät kurssilla käsiteltäviä sisältöjä ja sisältävät kaiken kurssin sisältöön kuuluvan
materiaalin. Sisältöluvut on numeroitu välillä 0-11 niin, että luvun numero vastaa viikkoa, jolla
luvun sisältöä käsitellään kurssilla ja luku 0 käsittelee itse opasta ja sen käyttöä. Näin opasta
on helppo seurata kurssin edetessä.

\newthought{Jokaista sisältölukua} vastaa oppaan toisella puoliskolla yksi bonusluku. Bonusluvut
tarjoavat laajempia ja syvempiä katsauksia Javaan ja oliopohjaiseen ohjelmointiin. Ne eivät aina
syvennä suoraan vastaavan sisältöluvun materiaaliin liittyviä aiheita, mutta myös niiden järjestys
on suunniteltu niin, että käyttäjä voi opiskella yhden luvun viikossa.

\newthought{Bonusluvut on tarkoitettu} hyödyllisiksi ja hauskoiksi lisälukemistoiksi. Opas on
suunniteltu niin, että bonusluvut eivät sisällä kurssin oppimistavoitteisiin luokiteltua sisältöä.
Niiden lukeminen on siis täysin vapaaehtoista.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Termistö ja kieli oppaassa}
\label{kielestä}

\newthought{Oppaan pääasiallisena} kielenä koodiesimerkkejä lukuunottamatta toimii suomi muun
kurssimateriaalin kielivalinnan mukaan. Oppaan käyttämä termistö on tämän vuoksi käännetty Javan
avainsanoja lukuunottamatta suomeksi. Olisi kuitenkaan turha kiistää englannin ehdotonta ylivaltaa
tietojenkäsittelytieteen pääkielenä. Tämän vuoksi oppaan sanastosta löytyy jokaisen termin
selityksen lisäksi termin englanninkielinen vastine.

\newthought{Opas pyrkii} korostamaan tärkeää termistöä sanaston opettelun helpottamiseksi.
Jokainen tärkeä termi on kerätty oppaan sanastoon lyhyen selityksen ja termin englanninkielisen
vastineen kera. Sanastosta löytyvät termit on myös korostettu ensimmäisessä esiintymisessään.
Sanastotermeillä tämä korostus näkyy kursivoituna kirjoitusasuna ja termin perässä esiintyvänä
sulkuihin suljettuna englanninkielisenä vastineena termille. Vastine on niin ikään kursivoitu.
Koko korostettu kirjoitusasu termille näyttää siis tältä: \newengnogls{esimerkki}{example}

\newthought{Opaan teoriateksti} sisältää sanastosta löytyvien konseptuaalisesti tärkeiden termien
lisäksi myös Javan avainsanoja. Nämä on erotettu muusta korostetusta termistöstä alleviivauksilla
ja kääntämättömyydellä. Ensimmäisellä esiintymiskerrallaan Javan avainsanat ovat lisäksi
kursivoituja. Ensimmäistä kertaa esiintyvä Javan avainsana näyttää tältä: \newjavanogls{example}
ja uudestaan mainittu tältä: \javanogls{example}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Koodiesimerkit oppaassa}
\label{koodiesimerkeistä}

\newthought{Opas tarjoaa} kattavat koodiesimerkit kaikista siinä käsiteltävistä aihealueista.
Koodiesimerkit ovat lyhyitä, toimivia, koodinpätkiä ja ne sijaitsevat heti esitellyn konseptin
yhteydessä. Kaikki oppaan koodiesimerkit on koottu yhteen *tänne*. %TODO lisää koodien sijainti!

\newthought{Koodiesimerkit on kirjoitettu} Javan virallisen tyylioppaan suosittelemien
ohjelinjojen mukaisesti. Kaikki muuttujat, luokat ja metodit on nimetty englanniksi, mutta koodi
on kommentoitu suomeksi. Kommentointi ei noudata hyvää ohjelmointityyliä vaan kommentit ovat
koodin opetusmaisen luonteen vuoksi monisanaisempaa ja yleisempää kuin suosituksissa.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Oliopohjainen ajattelu}
\label{olioista}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Abstraktio laadukkaan koodin pohjana}
\label{abstraktiosta}

\newthought{Oliopohjainen ohjelmointi} on ohjelmointiparadigma, joka on kehitetty vastaamaan
ohjelmistotuotannon peruskysymykseen: kuinka kirjoittaa ymmärrettävää ja ylläpidettävää koodia
helposti?

\newthought{Yksi helpoimmista} ja yleisimmistä tavoista selkeyttää koodikantaa on
\neweng{abstraktio}{abstraction}: yleisten toimintojen ja kutsusarjojen eristäminen ennalta
määriteltyihin koodipaloihin. Nämä palat tunnetaan nimellä \neweng{funktio}{function}. Tällä
tavalla jaettuja kutsusarjoja voidaan uusiokäyttää ja ohjelman muokkaaminen helpottuu, kun
kutsusarjan päivittäminen tapahtuu vain yhdessä keskitetyssä paikassa.

\newthought{Käskysarjat ovat} kuitenkin vain puolikas toimivasta ohjelmistosta. Toinen ja aivan
yhtä tärkeä puoli on data, jota käskysarjoilla käsitellään. Myös tämän datan abstraktio on
mahdollista proseduraalisen ohjelmoinnin puitteissa muokattavilla tietorakenteilla. Tällaisestä
hyviä esimerkkejä ovat esimerkiksi Pythonin class-avainsanalla määritellyt luokat, jos niitä
käytetään vain datan ryhmittämiseen tai C-kielen \neweng{tietue}{struct}.

\newthought{Nämä abstraktiotyypit} ovat kuitenkin erotettuja toisitaan, eivätkä huomioi
käskysarjojen ja datan yhteyttä. Lähes poikkeuksetta tiettyjä funktioita kutsutaan koodissa
monessa paikkassa parametreinään toistuvasti sama tietorakenne. Eikö siis olisi järkevää yhdistää
datan ja sitä käsittelevien funktioiden sijainti koodissa?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Oliopohjaisen ajattelun perusteet}
\label{oliopohjaisesta ajattelusta}

\newthought{Olio-ohjelmoinnissa ohjelmisto} koostuu kokonaan keskenään kommunikoivista yksiköistä.
Näille yksiköille vakiintunut kutsumanimi on \neweng{olio}{object}. Oliot koostuvat datasta ja
sitä manipuloivista käskysarjoista, jotka tunnetaan nimellä \neweng{metodi}{method}. Se on
oliopohjaisen ohjelmoinnin nimi olioon sidotulle funktiolle, termiä \gls{funktio} ei juuri
käytetä.

\newthought{Ohjelmisto luo} kaikki käyttämänsä oliot ohjelmoijan tekemien muottien pohjalta.
Tälläinen muotti, eli \neweng{luokka}{class} voi luoda itsestään yleensä rajattoman määrän olioita
ajon aikana. Luokan ja olion ero on yksi oliopohjaisen ohjelmoinnin tärkeimmistä käsitteistä ja
sen ymmärtäminen alusta lähtien on kriittistä oliopohjaisen ohjelmoinnin opiskelussa.

\newthought{Jokainen olio} on jonkin luokan \neweng{instanssi}{instance}. Saman luokan eri
instanssit omistavat identtiset metodit, mutta instansseihin säilötty data on uniikki jokaiselle
instansille ja instanssin metodit käsittelevät tätä uniikkia dataa. Luokka määrittää nämä metodit
ja kertoo minkä tyyppiset datakentät jokaiselta luokan instanssilta löytyvät. Tästä lähtien
opas käyttää termiä "luokka" viitatessaan ohjelmoijan määrittämään olio muottiin eli puhuttaessa
suunnitteluperiaatteista ja koodin kirjoittamisesta ja termiä "olio" vain puhuessaan selkeästi
koodissa sijaitsevasta luokan ilmentymästä.

\newthought{Tälläinen jaottelu} järjestää koodia proseduraalista koodia luonnollisempiin osiin.
Tästä syystä oliopohjaista ohjelmointia esitellessä mainitaan usein sen kyky luoda koodin sisällä
järjestelmiä, jotka muistuttavat todellisen maailman rakenteita. Vaikka tämä pitää paikkansa on
hyödyllistä ymmärtää alusta lähtien, ettei oliopohjaisen ohjelmoinnin tavoitteena ole luoda yksi
yhteen oikean maailman kanssa samoin toimivaa järjestelmää. Sen sijaan oikea oliopohjaisen
ohjelmoinnin tavoite on luoda järjestelmä, joka koostuu pienistä tarkasti toisistaan erotelluista
osista, jotka kommunikoivat keskenään vain selkeästi määriteltyjä rajapintoja pitkin.

\newthought{Käytännössä laadukasta} oliopohjaista ohjelmistoa voidaan täten verrata esimerkiksi
moderniin modulaarisesti suunniteltuun autoon. Siinä missä auton moottori, pyörät tai verhoilu
ovat muokattavissa asiakkaan toiveiden ja budjetin mukaan, on laadukkaan oliopohjaisen ohjelmiston
osien, kuten vaikka autorisaatiomoduulin tai tietokantayhteyden laajentaminen ja muokkaaminen
mahdollista koskematta muuhun ohjelmistoon.

\newthought{Tämä kuulostaa} kunnianhimoiselta ja monimutkaiselta tavoitteelta, joten on tärkeää
edetä sopivan pienissä paloissa. Samoin kuin laadukas oliopohjainen ohjelmisto koostuu pienistä
paloista, kasataan ohjelmiston tekemiseen vaadittu tieto pieni pala kerrallaan. Tässä kappaleessa
esiteltyjä termejä ja käsitteitä tullaan syventämään oppaan tulevissa kappaleissa yksitellen,
joten vaikka tiedon määrä voi tuntua nyt kohtuuttomalta ei kannata huolestua liikaa.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Koodin laadun mittaamisesta}
\label{koodin laadusta}

\newthought{Jotta ohjelmistojen} modulaarisuus saadaan toivotulle tasolle on tärkeää miettiä mitä
metodeja tai dataa luokka paljastaa muulle ohjelmistolle. Oliopohjaiset kielet sisältävätkin
yleensä jonkin keinon rajoittaa datakenttien ja metodien näkyvyyttä luokan ulkopuolelle. Tämä
näkyvyyden rajaaminen ja tarkkojen vastuiden määrittäminen tunnetaan nimellä
\neweng{enkapsulaatio}{encapsulation}.

\newthought{Luokan paljastamat} datakentät ja metodit kertovat ulkopuoliselle ohjelmistolle, mitä
luokasta luodut oliot voivat tehdä ja mitä niiltä voi odottaa. Tämä muodostaa sopimuksen luokan ja
muiden luokan paljastamia metodeja tai datakenttiä käyttävien luokkien välillä. Tätä sopimusta
kutsutaan nimellä \neweng{rajapinta}{interface}. Rajapinnan abstraktia käsitettä ei pidä sekoittaa
Javan samankaltaiseen "interface"-avainsanaan, joka esitellään myöhemmin.

\newthought{Yksi olio-ohjelmoinnin nyrkkisäännöistä} on pitää huolta, että jokainen luokka
suorittaa yhden ja vain yhden tehtävän. Tämä tarkoittaa luokan rajapinnan pitämistä minimaalisena,
eli korkeaa enkapsulaatiota. Tämän lisäksi ohjelmiston peruslaatua voidaan arvioida käsitteillä
\neweng{koheesio}{cohesion} ja \neweng{pariutuminen}{coupling}.

\newthought{Koheesio voidaan arvioida} luokkakohtaisesti luokan metodien ja datakenttien
yhteistoiminnan perusteella. Mitä tiiviimmin metodit ja datakentät ovat yhteistyössä ja mitä
vähemmän luokassa on metodeja ja datakenttiä, jotka eivät ole vuorovaikutuksissa muun luokan
kanssa, sitä korkeampi koheesio luokalla on. Korkea koheesio kulkee siis pitkälti käsi kädessä
tiukan enkapsulaation kanssa. Mitä vähemmän luokka paljastaa itsestään muulle ohjelmistolle, sitä
tiukemmin sen metodit ja datakentät yleensä komminkoivat keskenään.

\newthought{Pariutuminen tarkoittaa} ohjelmiston luokkien riippuvuutta toisista ohjelmiston
luokista. Siitä puhutaan usein asteikolla \newengnogls{löysä}{loose}-\newengnogls{tiukka}{tight}.
Löysästi pariutineessa ohjelmistossa jokainen luokka on riippuvainen vain muutamasta muusta
luokasta ja riippuvaisuudet muistuttavat usein enemmän ketjua tai puuta kuin verkkoa.

\newthought{Koheesio ja pariutuminen} kulkevat usein käsi kädessä: Korkea koheesio johtaa löysään
pariutumiseen ja matala koheesio tiukkaan pariutumiseen. Enkapsulaatio mukailee yleensä koheesiota
niin että korkeasta koheesiosta seuraa korkea enkapsulaatio ja toisin päin. Kaikki kolme ovat
tärkeitä mittareita puhuttaessa oliopohjaisen ohjelmiston laadusta. Vaikka oppaan tärkein tehtävä
onkin opettaa lukija koodaamaan Javalla, eikä niinkään koodaamaan huipputason koodia, on näiden
käsitteiden olemassaolo ja merkitys hyvä tiedostaa. Tämä auttaa ymmärtääkseen oliopohjaisten
kielten suunnittelua ja etuja suhteessa muihin ohjelmointikieliin ja saattaa myös parantaa
tuotetun koodin laatua huomaamattomasti.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Javan perusteet}
\label{perusteet}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	

\section{Java ohjelmointikielenä}
\label{javasta}

\newthought{Java} on staattisesti tyypitetty korkean tason oliopohjainen ohjelmointikieli, joka
pyrkii standardisoimaan ohjelmien kirjoittamisen alustasta riippumatta. Java-ohjelmat käännetään
bittikoodiksi, joka ajetaan Java-virtuaalikoneella siten, että tismalleen sama koodi voidaan ajaa
jokaisella alustalla, jolle virtuaalikone voidaan asentaa.

\newthought{Tästä syystä} Java toimii tismalleen samoin kaikilla käyttöjärjestelmillä. Tämä
yhdessä Javan helposti opittavan syntaksin ja oliopohjaiseen suunnitteluun pakottavan luonteen
ohella on tehnyt Javasta yhden käytetyimmistä ohjelmointikielistä teollisessa ohjelmoinnissa.

\newthought{Javan syntaksi} on saanut paljon vaikutteita C-kielestä. Muun muassa kaarisulkeiden
käyttö koodin osien erotteluun ja suurin osa ohjausrakenteiden nimistä on suoraan C-kielestä
kopioitua.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Javan syntaksin alkeet}
\label{syntaksin alkeista}

\subsection{Kommentointi}
\label{kommentointi}

\newthought{Suurin osa} ohjelmointikielistä tukee ainakin yhtä kommentointisyntaksia. Javassa on
kaksi pääasiallista tapaa merkata koodissa oleva teksti kommentiksi. Yhden rivin kommentti voidaan
aloittaa "//"-merkkiparilla, kun taas monen rivin kommentti suljetaan "/*"- ja "*/"-merkkien
väliin. Seuraava esimerkki esittää kommentointisyntaksin vielä tarkemmin. Älä välitä vielä itse
koodista, sen tehtävä on vain selventää miten kommenttien sijoittelu vaikuttaa koodin toimintaan.

\code{week2/basicexamples}{Commenting}{Kommentointi Javassa}

\subsection{Primitiiviset tietotyypit ja String}
\label{tietotyypit}

\newthought{Yksiä tärkeimmistä} koodin osista ovat ehdottomasti \textit{\gls{muuttuja}t}
\eng{variable}. Ne ovat koodissa määriteltyjä tietokenttiä, jotka kykenevät säilömään joko jonkin
luokan instanssin, tai kokonaislukumuodossa esitetyn simppelin datayksikön. Koska Java on 
\neweng{staattinen kieli}{statically typed language}, täytyy siinä jokaisen muuttujan tietotyyppi
määritellä muuttujan määrittelyn yhteydessä. Muuttujan tyyppi voi olla joko jokin käyttäjän
määrittelemä luokka, jokin Javan standardikirjaston luokka, tai jokin \neweng{primitiivinen
tietotyyppi}{primitive data type}.

\newthought{Java sisältää} yhteensä kahdeksan primitiivistiä tietotyyppiä. Nämä määritellään
pienellä alkukirjaimella kirjoitetulla tyypin nimellä. Seuraava taulukko ja koodiesimerkki
sisältävät kaikki primitiivisten tietotyyppien nimet, arvojoukot, oletusarvot ja määrittelytavan
koodissa.

\bigskip
\begin{center}
\footnotesize
\begin{tabular}{lll}
\toprule
Avainsana & Oletusarvo & Arvojoukko \\
\midrule
\newjava{bool} & false & true ja false \\
\addlinespace
\newjava{byte} & 0 & $-2^7$:stä $2^7-1$:een \\
\addlinespace
\newjava{short} & 0 & $-2^{15}$:stä $2^{15}-1$:een \\
\addlinespace
\newjava{int} & 0 & $-2^{31}$:stä $2^{31}-1$:een \\
\addlinespace
\newjava{long} & 0L & $-2^{63}$:stä $2^{63}-1$:een \\
\addlinespace
\newjava{float} & 0.0f & noin $1.4e-45$:stä noin $3.4e+38$:aan \\
\addlinespace
\newjava{double} & 0.0d & noin $4.9e-324d$:stä noin $1.8e+308d$:hen \\
\addlinespace
\newjava{char} & 0 & $0$:sta $2^{16}-1$:een \\
\bottomrule
\end{tabular}
\end{center}

\code{week2/basicexamples}{DataTypes}{Primitiiviset tietotyypit Javassa}

\newthought{Näiden tietotyyppien} lisäksi Javasta löytyy monta valmiiksi määriteltyä luokkaa datan
säilömistä varten. Näistä tärkein kielen opettelua aloitettaessa on ehdottomasti merkkijonoja
säilövä \newjava{String}-luokka. Tämä luokka mahdollistaa dynaamisten merkkijonojen helpon
luomisen ja manipulaation. String-luokka on voimakas työkalu ja sen toimintaan kannattaa
kiinnittää huomiota Javan opiskelun alussa.

\newthought{String-tyyppisen} muuttujan arvo kerrotaan ohjelmalle antamalla String-tyypin
muuttujalle toivottu merkkijono suljettuna normaalien lainausmerkkien (") sisään. Yksittäiset 
hipsut (') eivät toimi, koska niitä käytetään char-tyypin muuttujien määrittämiseen.

\code{week2/basicexamples}{StringUsage}{String-tyypin muuttujan määrittäminen}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Toimivan ohjelman perusteet}
\label{ohjelman perusteista}

\subsection{Oliopohjaisen ohjelman ajaminen: main-metodi}
\label{main}

\newthought{Luokat ovat} Javan ydin ja kaiken koodin rakennuspala. Kaikki koodi Javassa on
suljettava luokan sisään, niin myös ohjelman ajon aloittava koodi. Tästä syystä jokaisessa
Java-ohjelmistossa on yksi erikseen määritelty pääluokka, joka sisältää main-metodin. Tämä
metodi määritellään avainsanoilla \java{public} \java{static} \java{void} ja sen 
\neweng{signatuuri}{signature} on \java{main}(\java{String}[] args). Void-avainsana selitetään
myöhemmin tässä kappaleessa ja static-avainsana kappaleessa \nameref{static}.
Toistaiseksi riittää sisällyttää nämä avainsanat annetussa järjestyksessä main-metodin
määritelmään. Pääluokan ei tarvitse olla ainoa main-metodin sisältävä luokka, mutta vain yhden
ennalta määritellyn luokan main-metodi ajetaan ohjelman käynnistyksen yhteydessä.

\subsection{Luokan luomisen syntaksi}
\label{luokka}

\newthought{Luokka luodaan} Javassa luokat luodaan \newjava{class} avainsanalla. Avainsana
tarkistaa edestään myös näkyvyysmääreen (käsitellään seuraavassa alakappaleessa). Yleisin tapa
luoda luokka on näkyvyysmääreellä \java{public}. Koko määritelmä koostuu näkyvyysmääreestä,
\java{class} -avainsanasta ja luokan nimestä, jota seuraa luokan käyttäytymisen määrittävä koodi
hakasulkeisiin suljettuna. Seuraavassa koodiesimerkissä on kommentoitu auki yksinkertaisen
pääluokan luonti (huomaa pääluokan nimeämisen vapaus) ja sen sisään "Hello world!" tulostavan
main-funktion lisääminen.

\subsection{Tulostaminen Javassa}
\label{print}

\newthought{Tekstin tulostaminen} komentoikkunaan on varmasti tuttua aiemmasta
ohjelmointikokemuksesta. Javassa tulostukseen käytetään yleensä standardikirjaston 
\newjava{System}-luokan out-muuttujassa tallennettuna olevaa PrintStream-luokan instanssia, joka
edustaa oletustulostevirtaa. Jos et ymmärtänyt edellistä lausetta, se ei haittaa. Tärkeintä on
tietää, että Javassa helpoin tapa tulostaa on kutsua "\java{System}.out" - sijainnista sopivaa
tulostusmetodia. Opas on käyttää suurimmaksi osaksi "println"-metodia, joka ottaa merkkijonon ja
tulostaa sen, sekä rivinvaihdon. On huomioitavaa, että println, samoin kuin muutkin
\java{System}.out:sta löytyvät tulostusmetodit ovat todella monipuolisia ja tukevat monenlaisia
tapoja tulostaa toivottua tekstiä. Toistaiseksi nämä ominaisuudet eivät kuitenkaan ole
ajankohtaisia ja opas käyttää "\java{System}.out.println" metodia tulostukseen.

\code{week2/basicexamples}{HelloWorld}{Yksinkertaisen pääluokan ja main-funktion luominen Javassa}

\subsection{Metodin määritteleminen ja kutsuminen}
\label{metodi}

\newthought{Metodin määritelmä} koostuu Javassa metodin paluuarvon tyypistä, metodin nimestä
ja sitä seuraavasta sulkuihin suljetusta parametrien määritelmästä ja lopulta kaarisulkuihin
suljetusta metodin koodista. Metodin parametrit vaativat pythonista poiketen parametrin nimen
määritelmän lisäksi myös parametrin tyypin määrittämistä. Vastaavasti metodia kutsuttaessa on
argumenttien, jolla metodia kutsutaan oltava metodin yhteydessä määriteltyä tyyppiä. Jos metodi
ei palauta mitään, määritellään sen paluuarvoksi \newjava{void}.

\newthought{Metodien nimeämisessä} suositellaan Javassa vahvasti niin sanottua camel case-
nimeämistapaa. Tavassa kaikki nimen sanat kirjoitetaan yhteen niin, että nimi aloitetaan
pienellä kirjaimella ja seuraavat sanat aloitetaan isolla alukirjaimella. Täten esimerkiksi
"parse user name"-metodin nimi on muotoa "parseUserName". On myös vahvasti suositeltua käyttää
verbiä metodin nimessä. Tämä helpottaa metodien ja muuttujien erottamista ja pakottaa
myös ajattelemaan koodin laatua: hyvä metodi tekee vain yhden asian, joten jos nimeäminen
simppelissä verbimuodossa ei onnistu, olisi ehkä syytä jakaa metodi useampaan pienempään
metodiin. Metodin palautusarvo määritellään \newjava{return}-avainsanalla. Avainsana lopettaa
metodin ajamisen ja palauttaa avainsanasta välilyönnillä erotetun arvon.

\newthought{Metodia kutsutaan} Javassa pistenotaatiolla metodin omistavasta oliosta. Tämä
olio on yleensä tallennettuna muuttujaan jonkin toisen luokan sisällä. Esimerkiksi jos olio
on tallennettu muuttujaan "object" ja omistaa metodin "doStuff(int number)", kutsuttaisiin
metodi notaatiolla "object.doStuff(322)". Jos metodille on määritelty paluuarvon tyyppi, kutsu
palauttaa tämän tyypin muuttujan, jota voidaan käyttää koodissa.

\code{week2/methodexample}{MethodClass}{Metodin luominen Javassa}
\code{week2/methodexample}{Main}{Metodin kutsuminen Javassa}

\subsection{If-lause ja else-lause}
\label{if else}

\newthought{Ohjelmointi on} pohjimmiltaan logiikkaa. Ohjelman ajon muokkaaminen olosuheiden
mukaan tekee ohjelmasta älykkään. Yksinkertaisin tapa muokata ohjelman toimintaa on
\newjava{if}-lause ja sen kanssa toimiva \newjava{else}-lause. Lauseet mahdollistavat ennalta
määriteltyjen koodin osien ajamisen annetun lauseen totuusarvon mukaan.

\newthought{If-lause} alkaa if-avainsanalla, jota seuraa suluilla ympäröity lause, joka saa
totuusarvon true tai false. Tätä ehtolausetta seuraa kaarisulkuihin ympäröitynä itse if-lauseen
runko, eli koodi, joka ajetaan jos ehtolause on tosi.

\newthought{Else-lause} on mahdollinen jatko if-lauseelle ja sijaitsee aina if-lauseen
ehdollisesti ajettavan koodiosan jälkeen. Lause alkaa else-avainsanalla. Tämän jälkeen on
mahdollista kirjoittaa uusi if-lause, tai aloittaa suoraan ehdollisen koodin määrittely. If-
else -lauseita voi tarvittaessa ketjuttaa niin monta kuin tarvitaan, joskin pitkät if-else
-ketjut ovat yleensä merkki huonosta arkkitehtuurista ohjelmistossa.

\newthought{Seuraava koodiesimerkki} esittelee if- ja else-lauseiden käytön perusteet. Huomioi,
että normaalisti ehtolauseiden arvoa ei tiedetä ennen ohjelman ajoa, vaan se muuttuu dynaamisesti.

\code{week2/basicexamples}{IfElse}{Esimerkki if- ja else-lauseiden käytöstä}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lisää Javan konsepteja}
\label{ohjelman perusteista2}

\subsection{Rakentajat, luokan instanssin luominen ja this}
\label{new this}

\newthought{Olioiden hallinta} on Javalla ohejlmoinnin ytimessä. Koodissa on luotava uusia
instansseja sekä Javan standardikirjaston luokista, että käyttäjän itse määrittelemistä luokista.
Uusi instanssi luokasta luodaan \newjava{new}-avainsanalla. Avainsanaa seuraa luotavan luokan
nimi ja luomisen parametrit sulkuihin suljettuna, tai tyhjä pari sulkuja.

\newthought{Luokan Instanssin} luonti tyhjänä ja alustamattomana on usein kömpelöä ja vaatisi
useita rivejä manuaalista arvojen asettamista jokaisen uuden instanssin luonnin yhteydessä.
Instanssien konfiguroimista varten Java tarjoaa \neweng{rakentaja}{constructor} -ominaisuuden.
Rakentaja on metodi, joka määritellään luokan sisällä erityisellä syntaksilla ja joka palauttaa
luokan instanssin. Rakentaja määritellään ilman paluuarvoa ja sen nimi on identtinen luokan nimen
kanssa. Rakentajan voi määritellä ottamaan mitä tahansa argumentteja kyseinen tapaus tarvitsee.
Rakentajametodi ei tarvitse \java{return}-avainsanaa, vaan palauttaa automaattisesti
käsittelemänsä instanssin.

\newthought{Rakentajan yhteydessä} on tärkeää puhua \newjava{this}-avainsanasta. This tarjoaa
ohjelmalle mahdollisuuden viitata luokan instanssiin, jolle jokin metodi kuuluu. This toimii
vain rakentajassa ja instanssiin sidotussa metodissa, eli konteksteissa, joissa instanssi, johon
viitataan on tiedossa. Täten rakentajassa voidaan yhdistämällä this-avainsana ja pistenotaatio
viitata helposti rakennettavaan instanssiin.

\newthought{Seuraava koodiesimerkki} esittelee rakentajan määrittelemisen ja new-avainsanan
käytön rakentajan kanssa. On huomioitavaa, että seuraavassa alakappaleessa käsiteltävä
ylikuormittaminen toimii myös rakentajametodeihin, eli luokalla voi olla useampi ylikuormitettu
rakentajametodi. Koodiesimerkki kuitenkin käyttää vain yhtä rakentajametodia.

\code{week2/constructorexample}{ClassWithConstructor}{Rakentajan luonti Javassa}
\code{week2/constructorexample}{Main}{\java{new}-avainsanan käyttö}


\subsection{Metodin ylikuormitus}
\label{overloading}

\newthought{Joskus on} toivottavaa tukea useampaa eri yhdistelmää argumentteja metodikutsulle.
Pythonissa tämä onnistuu oletusarvoilla, mutta Java ei tue oletusarvoja argumenteille. Sen
sijaan Javassa on olemassa konsepti nimeltä \neweng{ylikuormitus}{overloading}.
Ylikuormittamisessa määritellään koodissa jo käytetty metodinimi uudestaan, erilaisilla
argumenteilla. Jos argumenttejä on sama määrä kuin ylikuormitettavassa metodissa, pitää vähintään
yhden argumentin tietotyypin poiketa alkuperäisestä metodista. Jos argumenttejä on eri määrä, ei
niiden tietotyypeillä ole väliä. Java hakee metodikutsun yhteydessä automaattisesti kutsun
signatuuria vastaavan version ylikuormitettua metodia kutsuttaessa. Seuraavassa esimerkissä
esitellään ylikuormitetun metodin käyttö luomalla tulostusmetodi, joka ilmoittaa, onko
tulostettavan muuttujan tietotyyppi int vai String.

\code{week2/overloadingexample}{OverloadedPrinter}{Lapsiluokka ylikuormittamisesimerkkiin}
\code{week2/overloadingexample}{Main}{Ylikuormittaminen Javassa}

\subsection{Näkyvyysmääreet}
\label{näkyvyysmääreet}

\newthought{Lähes kaikkien} koodin osien, kuten muuttujan, metodin, interface-luokan tai luokan
luominen Javassa tukee kyseisen koodin osan näkyvyyden määrittämistä. Tämä määritelmä on nimeltään 
\neweng{nakyvyysmaare}{access modifier}. Kuten oppaassa aiemmin todettiin, yksi olio-ohjelmoinnin
ydinideoista on \new{enkapsulaatio}, eli koodin osien vastuiden tarkka rajaaminen. Näkyvyysmääreet
ovat tärkein työkalu tämän suhteen. Näkyvyysmääre rajoittaa ohjelmiston osan, kuten luokan tai
luokan ominaisuuden näkyvyyttä muulle ohjelmalle seuraavan taulukon mukaisesti:

\bigskip
\begin{center}
\footnotesize
\begin{tabular}{lll}
\toprule
Avainsana & Näkyvyys & Käyttökohteet \\
\midrule
\newjava{private} & Vain tämä luokka & Luokkien ominaisuudet \\
\addlinespace
Ei avainsanaa (default) & Kaikki luokat tässä paketissa & Luokat ja luokkien ominaisuudet \\
\addlinespace
\newjava{protected} & Kaikki luokat tässä paketissa ja kaikki tämän luokan perivät luokat &
Luokkien ominaisuudet \\
\addlinespace
\newjava{public} & Kaikki luokat kaikkialla & Luokat ja luokkien ominaisuudet \\
\bottomrule
\end{tabular}
\end{center}

\newthought{Private ja protected} ovat siis näkyvyysmääreitä, jotka toimivat vain luokan
ominaisuuksien näkyvyyden rajaamisessa, kun taas public ja oletusnäkyvyys toimivat myös luokkien
näkyvyyden määrittämisessä. Tämä johtuu siitä, että private ja protected ovat suoraan sidottuja
luokkaan, jossa ominaisuus sijaitsee. Protected on lisäksi tiukasti sidoksissa periytymiseen, joka
käsitellään myöhemmin oppaan alaluvussa \nameref{protected} joten sen toiminnallisuuden
ymmärtäminen ei ole vielä ajankohtaista.

\newthought{Tähän mennessä} oppaassa on vältetty näkyvyysmääreiden käyttöä, eli niitä on käytetty
vain main-metodien määrittelemisen yhteydessä. Tällöin Java-kääntäjä asettaa näkyvyydeksi
automaattisesti oletusnäkyvyyden (default), jossa luokka, tai sen ominaisuus näkyy kaikkialle
sen määrittelypaketin sisällä, muttei muualle. Tämä ei ole suositeltavaa, vaan jokaisen luokan
ja luokkien jokaisen ominaisuuden näkyvyyden tarve pitäisi arvioida erikseen ja asettaa kullekin
tiukin mahdollinen näkyvyysmääre. Tämä tyyli paitsi takaa mahdollisimman korkean enkapsulaation,
myös tekee ohjelmistosta tehokkaamman, koska vain luokan sisällä näkyvät metodit voidaan optimoida
tehokkaammin ohjelman kääntämisen yhteydessä.

\newthought{Seuraava koodiesimerkki} sisältää pääluokan ja kaksi apuluokkaa ja esittelee näin
\java{public} ja \java{private} avainsanojen toimivuuden. Avainsana \java{protected} on esitelty
koodiesimerkissä periytyvyyden yhteydessä kappaleessa *x*. % TODO: lisää luku

\code{week2/accessmodifierexample}{FirstClass}{Ensimmäinen näkyvyysmääre-esimerkin luokka}
\code{week2/accessmodifierexample}{SecondClass}{Toinen näkyvyysmääre-esimerkin luokka}
\code{week2/accessmodifierexample}{Main}{Näkyvyysmääre-esimerkin pääluokka}

\subsection{Noutajat ja asettajat}
\label{get set}

\newthought{Java neuvoo} käyttäjiään alustamaan kaikki muuttujat \java{private} näkyvyysmääreellä.
Tämä tarkoittaa, että koodatessa virallisten suositusten mukaista Javaa ohjelmoija tuottaa vain
luokkia, joiden muuttujat näkyvät ainoastaan kunkin luokan sisällä. Kuitenkin monesti luokan
säilömää dataa tarvitaan luokan ulkopuolella. Tämä ei ole suunnitteluvirhe, vaan yksinkertainen
ohjelmoinnin totuus. Tätä varten Javaan on vakiintunut kaksi tärkeää metodityyppiä:
\neweng{noutaja}{getter} ja \neweng{asettaja}{setter}.

\newthought{Noutaja, eli getter} on funktio, jonka tehtävä on noutaa luokan sisällä yksityiseksi
määritelty muuttuja luokan ulkopuoliseen käyttöön. Noutaja nimetään camelCase-tyylisesti
lisäämällä noudettavan muuttujan nimen eteen "get". Tällöin muuttujan "privateVariable"
noutajafunktion nimi on "getPrivateVariable". Noutajafunktio ei yleensä ota argumentteja ja
palauttaa vain noudettavan muuttujan. Noutajan tehtävä on tarjota rajattu pääsy luokan
säilömään dataan luokan ulkopuolelle. Noutajien käyttö mahdollistaa myös esimerkiksi laiskan
alustamisen muuttujille, joiden alustaminen on raskasta, muttei aina tarpeellista.

\newthought{Asettaja, eli setter} puolestaan on funktio, jonka tehtävä on asettaa luokan
ulkopuolelta saatava arvo luokan sisällä yksityiseksi määriteltyyn muuttujaan. Asettaja nimetään
noutajan tapaan camelCase-tyylisesti lisäämällä muuttujan nimen eteen "set". Täten edellä mainitun
"privateVariable"-muuttujan asettajan nimi on "setPrivateVariable". Asettajafunktio ottaa yleensä
asetettavan muuttujan tyyppiä olevan instanssin eikä palauta mitään. Samoin kuin noutajat,
asettajat rajoittavat luokan ulkopuolista pääsyä luokan säilömään dataan. Lisäksi asettajat
vastaavat usein luokan ulkopuolelta tulevan datan validoinnista ennen sen tallentamista
muuttujaan.

\newthought{Noutajien ja asettajien} käytön perusteet on esitetty seuraavassa koodiesimerkissä.
Huomaa setPositiveNumber-metodissa toteutettava muuttujan validointi, joka ei olisi mahdollista,
jos muuttuja positiveNumber olisi julkinen Javan suositteleman yksityinen muuttuja, noutaja ja
asettaja -mallin sijaan.

\code{week2/gettersetterexample}{NumberStorage}{Ensimmäinen noutaja/asettajaesimerkin luokka}
\code{week2/gettersetterexample}{Main}{Noutaja/asettajaesimerkin pääluokka}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Syötteen vastaanottamisen perusteet}
\label{syötteestä}

\subsection{Käyttäjän syötteen vastaanottaminen Javassa}
\label{input}

\newthought{Komentoriviin perustuvan} ohjelman tuottaminen vaatii paitsi kykyä tulostaa
komentoriville tekstiä, myös kykyä kerätä käyttäjältä syötettä. Tätä varten Javasta löytyy
useampi luokka, joiden avulla voidaan kerätä haluttu syöte juuri ohjelmistolle sopivalla tavalla.
Näistä tärkeimmät ovat \newjava{Scanner}-lukka, \newjava{BufferedReader}- ja
\newjava{InputStreamReader}-luokat. Koska Java, kuten moni muu ohjelmointikieli, käsittelee
konsolisyötettä ja tiedostosyötettä samoin kaikkia näitä luokkia voi käyttää myös tiedostojen
lukemiseen, käyttäjäsyötteen lukemisen lisäksi. Huomioi, että syötteen pyytäminen on matalan
tason tapahtuma, jonka täyden toiminnallisuuden ymmärtäminen ei ole tarpeellista oppaan
käyttämiseksi. Seuraavat kappaleet avaavat koko syötteennoutoprosessin, mutta voit halutessasi
hypätä suoraan seuraavaan koodiesimerkkiin, jos haluat vain opiskella tarvittavan syntaksin.

\newthought{\java{Scanner}-luokka} ottaa sisäänsä jonkin luettavan olion ja mahdollistaa sen
parsimisen. Käyttäjän syöte tulee oletuksena standardikirjaston System-luokan in-muuttujaan,
joten Scanner-luokan rakentaminen System.in-argumentilla on helpoin tapa muodostaa käyttäjältä
syötettä keräävä olio. Tältä oliolta voi pyytää monia eri parsintametodeja, kuten seuraavan rivin
parsimista, tai seuraavan numeron parsimista. Todennäköisesti yleisin parsintametodi on rivin
parsiminen, joka tapahtuu Scanner-olion "nextLine()"-metodilla.

\newthought{\java{Scanner}}, joka on koottu suoraan System.in-streamin
päälle on helppo tapa vastaanotta käyttäjäsyötettä, mutta raa'a stream-olion lukeminen on
kohtalaisen raskas toimenpide. Java suosittelee puskuroimaan useasti luetut syötteet, olivat ne
tiedostoja tai konsolisyötteitä. Tätä varten on olemassa \java{BufferedReader}-luokka. Se ottaa
rakennettaessa puskuroitavan merkkijonovirran. BufferedReader voidaan antaa suoraan argumenttina
Scanner-oliolle luettavaksi syötteeksi.

\newthought{Ikävä kyllä} \java{System}.in ei ole merkkijonovirta, vaan tavuvirta. Sitä ei siis
voida käyttää raakana \java{BufferedReader}-olion rakentamiseen. Tavuvirta voidaan muuttaa
merkkijonovirraksi \java{InputStreamReader}-luokalla. Rakentamalla \java{InputStreamReader}
ja käyttämällä \java{System}.in-virtaa argumenttina, saadaan merkkijonovirta, joka sisältää
käyttäjän syötteen.

\newthought{Syötteen noutaminen} on ikävä kyllä Javassa monimutkainen prosessi. Seuraava
koodiesimerkki sisältää kuitenkin tarvittavan syntaksin toimivan Scanner-luokan instanssin
luomiseen. Kun instanssi on luotu kerran on sen käyttäminen onneksi simppeliä.

\code{week2/basicexamples}{UserInput}{Käyttäjän syötteen noutaminen Javassa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Kokoelmarakenteet, toistorakenteet ja lisää oliopohjaista ajattelua}
\label{perusteet2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Kokoelmarakenteet}
\label{kokoelmista}

\newthought{Ohjelmistot käsittelevät} yleensä huomattavia määriä dataa. Ei ole mielekästä, eikä
yleensä edes mahdollista määritellä kaikille mahdollisille datayksiköille omaa muuttujaansa.
Tätä varten ohjelmointikielistä löytyy kokoelmamaisia rakenteita, jotka ovat nimensä mukaisesti
yhteen muuttujaan tallennettavia datayksikkökokoelmia. Javan standardikirjasto sisältää useita
kokoelmarakenteita erityyppisiin tilanteisiin, mutta opas käy läpi vain yleisimmin käytetyt
kokoelmat.

\subsection{Taulukot}
\label{taulukot}

\newthought{Yksinkertaisin kokoelmarakenteista} on \neweng{taulukko}{array}, joka löytyy
simppeliytensä vuoksi useasta ohjelmointikielestä. Taulukko on tehokas rakenne indeksipohjaisissa
hauissa ja lisäyksissä ja sen ylimääräinen muistijalanjälki on pieni verrattuna muihin
tietorakenteisiin. Oppaassa on jo näkynyt taulukkomuuttujia, sillä \java{main}-funktio ottaa
komentoriviargumentit muodossa String[], eli merkkijonoista koostuvana taulukkona. On huomioitava,
että Java vaatii kaikkien taulukon alkioiden olevan samaa tyyppiä.

\newthought{Taulukko alustetaan} \java{new}-avainsanalla. Avainsanan jälkeen annetaan taulukon
alkoiden tietotyyppi, jonka perään kirjoitetaan välittömästi hakasulkujen sisään taulukon koko.
Muuttuja, joka sisältää taulukon määritellään puolestaan normaalin muuttujan määrittelyn tapaan,
mutta muuttujan tietotyypin perään lisätään tyhjä pari hakasulkuja. Taulukon alkoihin viittaaminen
puolestaan tapahtuu kirjoittamalla viitattavan alkion indeksi hakasulkuihin taulukon sisältävän
muuttujan perään. Viittaus toimii samoin sekä alkion tallennuksessa, että alkion noutamisessa.

\newthought{Seuraava esimerkki} näyttää esimerkin taulukkojen luomisesta ja tallettamisesta
muuttujaan, sekä arvojen tallentamisesta olemassa olevaan taulukkoon ja arvojen noutamisesta
olemassa olevasta taulukosta.

\code{week3/arrayexample}{DataPoint}{Dataluokka käytettäväksi taulukkoesimerkissä}
\code{week3/arrayexample}{Main}{Taulukkojen käyttö Javassa}

\subsection{Paketit ja import}
\label{import}

\newthought{Tähän mennessä} oppaan käyttämät eri tiedostossa sijaitsevat luokat ovat aina olleet
osa samaa pakettia, sillä opas jakaa esimerkit paketteihin kappaleen mukaan. Samassa paketissa
olevat luokat ovat automaattisesti käytettävissä paketin sisällä, joten luokkia ei ole tarvinnut
tuoda tiedoston nimitilaan tiedoston alussa. Aina tarvittavat luokat eivät kuitenkaan sijaitse
samassa paketissa. Tätä varten Javassa on \newjava{import}-avainsana. Import-avainsanalla
listataan tiedoston alussa tiedoston nimitilaan paketin ulkopuolelta tuotavat luokat. Myös Javan
standardikirjasto sisältää luokkia, jotka on tuotava nimitilaan import-lauseella. Tästä hyviä
esimerkkejä ovat seuraavaksi käytävät \java{ArrayList} ja \java{HashMap}-luokat.

\subsection{Listat}
\label{listat}

\newthought{Todennäköisesti yleisin} tietorakenne datajoukkojen säilömiseen on lista. Javan
standardikirjasto sisältää useamman listamaisen implementaation, mutta niistä yleisimmin käytetty 
ja monikäyttöisin on \newjava{ArrayList}. Se muistuttaa pythonin listaa toiminnaltaan, mutta
pystyy Javan staattisen tyypityksen vuoksi säilömään vain yhden tyyppisiä muuttujia. Toisaalta on
huomioitava, että mikäli ohjelmassa nousee ikinä tarve säilöä usean tyyppisiä muuttujia samaan
listaan, on ohjelma luultavasti epäoptimaalisesti suunniteltu. ArrayList ei kykene säilömään
primitiivisiä tietotyyppejä.

\newthought{\java{ArrayList} tukee} pythonin listan tapaan indeksipohjaista hakua ja lisäystä,
alkoiden hakua kriteeripohjaisesti ja iterointia. Toisin kuin taulukko se on kooltaan dynaaminen
eikä sen kokoa siksi määritellä sen luonnin yhteydessä. Luonti tapahtuu \java{new}-avainsanalla,
mutta koska Javan täytyy tietää paitsi listan tyyppi, myös listan säilömien olioiden tyyppi, on
luomisen yhteydessä määriteltävä tämäkin. ArrayList on siis
\neweng{geneerinen luokka}{generic class}. Geneeristen luokkien luominen ja toimintaperiaate
ei ole tämän luvun aiheena, vaan ne käsitellään oppaan luvussa *x*. % TODO: lisää luku
Tässä kohtaa opasta ArrayListin geneerisyys on huomioitava vain uuden instanssin luonnin
yhteydessä, jolloin listan säilömä tyyppi on suljettava pienempi kuin- ja suurempi kuin -merkkien
väliin. Seuraava esimerkki näyttää ArrayList-instanssin luomisen, alkioiden lisäämisen, hakemisen
ja poistamisen.

\code{week3/basicexamples}{ArrayListUsage}{ArrayList-luokan käyttö Javassa}

\subsection{Hajautustaulut}
\label{HashMap}

\newthought{Välillä kokoelman} sisältämää dataa on tarve yhdistää muuhun dataan. Vaikka
olio-ohjelmoinnin hengen mukaisesti datan yhdistäminen tapahtuu luomalla uusi luokka tai
muokkaamalla olemassa olevaa luokkaa ei tämä ole aina mahdollista tai järkevää. Erityisesti
tilanteissa, joissa dataa haetaan jonkin avaimen avulla ei ole järkevää käyttää listaa, jossa on
tämän avaimen omaavia alkioita hitaan ja hankalan hakuoperaation vuoksi. Tämän vuoksi Javassa
on olemassa \newjava{HashMap}-luokka jonka perustana on \neweng{hajautustaulu}{hash table}
-tietorakenne.

\newthought{\java{HashMap}-luokka} säilöö avain-arvopareja ja on verrattavissa pythonin
dict-rakenteeseen, mutta vaatii kaikkien avainten olevan samaa tyyppiä ja kaikkien arvojen olevan
samaa tyyppiä, eikä takaa arvojen keskeneräisen järjestyksen säilymistä. Se on 
\java{ArrayList}-luokan tapaan geneerinen, mutta toisin kuin ArrayList, HashMap tarvitsee kaksi
luokkaa määritelmänsä yhteydessä. HashMap tukee avain-arvo -parin lisäämistä, arvon hakemista ja
postamista avaimen perusteella ja iterointia joko avainjoukon, arvojoukon tai avain-arvo -parien
yli. HashMap pystyy säilömään identtisiä arvoja, mutta jokaisen avaimen on oltava uniikki.
Seuraava esimerkki esittelee HashMap-instanssin luomisen, avain-arvo -parin lisäämisen ja
arvon hakemisen sekä poistamisen avaimen perusteella. ArrayListin tapaan HashMap ei tue
primitiivisten tietotyyppien säilömistä.

\code{week3/basicexamples}{HashMapUsage}{HashMap-luokan käyttö Javassa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Toistorakenteet}
\label{loopeista}

\newthought{Edellä esitellyiden} kokoelmarakenteiden esimerkkikoodista oli ehkä jo havaittavissa
toistuvat samankaltaiset kutsut, jotka aiheuttivat rumaa koodia ja pidensivät esimerkkejä turhaan.
Kuten missä tahansa itseään kunnioittavassa ohjelmointikielessä, myös Javassa on olemassa
toistorakenteita, joilla kokoelmien käsittely ja muut monesti toteutettavat koodin osat saadaan
kirjoitettua järkevämpään, luettavampaan ja helpommin muokattavaan muotoon.

\subsection{For-looppi}
\label{for}

\newthought{For-looppi} luodaan \newjava{for}-avainsanalla. Se poikkeaa pythonin for-loopista
ja muistuttaa sen sijaan c:n for-looppia. Pythonin for-looppi tunnetaan Javassa foreach-looppina
ja käsitellään myöhemmin. For-avainsanan jälkeen for-loopissa seuraa iterointiehto sulkujen
sisällä. Iterointiehto jaetaan kolmeen osaan kahdella puolipilkulla. Ensimmäinen osa kertoo,
mikä muuttuja toimii iterointiehtona, toinen millä kyseisen muuttujan arvoilla iterointia
jatketaan ja kolmas mitä muuttujalle tehdään jokaisen iteraation jälkeen. Yksi yleisimmistä
iterointiehdoista on "(int i = 0; i < n; i++)". Auki luettuna tämä tarkoittaa:

1: Määritä iterointimuuttuja "i", joka on tyyppiä "int" joka on alustettu arvoksi 0

2: Iteroi niin kauan, kun i on pienempi kuin tavoiteluku n

3: Jokaisen iteraation jälkeen kasvata i:n arvoa yhdellä

++ on Javan iterointioperaattori joka käydään tarkemmin läpi tämän luvun lopussa. Se kasvattaa
muuttujan arvoa yhdellä. Käytännössä koko iterointiehto siis tarkoittaa "Toista loopin rungossa
olevaa koodia n kertaa, niin että muuttujaan i on sidottu lukuarvo, joka kertoo mones iteraatio
on kyseessä." Muuttujaa i voidaan käyttää loopin ruumiin sisällä. 

\newthought{For-looppia} käytetään yleensä lukujoukkojen iteroimiseen esimerkiksi taulukkojen
alustuksessa. On huomioitavaa, että kokoelmien iterointi on yleensä helpompaa foreach-loopilla.
For-loopin iterointiehtona voi myös toimia jo olemassa oleva muuttuja, iterointiehdoksi ei ole
aina pakko luoda uutta muuttujaa. Jos iterointiehdoksi luodaan uusi muuttuja, se näkyy vain
loopin sisällä. Seuraava koodiesimerkki esittelee for-loopin luomisen ja käytön perusteet
käytännössä.

\code{week3/basicexamples}{ForLoop}{For-loopin käyttö Javassa}

\subsection{For-each-looppi}
\label{for each}

\newthought{Edellisessä kappaleessa} mainittiin, että kokoelmien yli iterointi on Javassa
helpompaa foreach-rakenteella, kuin for-rakenteella. Rakenteet muistuttavat toisiaan siinä
mielessä, että molemmat määritellään \java{for}-avainsanalla. Foreach-rakenteessa kuitenkin
avainsanaa seuraa iteroitavan kokoelman määritelmä sulkuihin suljettuna. Määritelmä koostuu
kahdesta puolipisteellä erotetusta osasta. Ensimmäinen osa kertoo, minkä tyyppiseen ja nimiseen
muuttujaan iteroitavat arvot sidotaan ja toinen, mistä kokoelmasta muuttujat haetaan. Looppi
iteroi koko kokoelman yli, sitoen annettuun muuttujaan jokaisen yksittäisen arvon kokoelmasta.
Tämä käyttäytyminen muistuttaa pythonin for-looppia. Seuraava koodiesimerkki näyttää kokoelman
yli iteroimisen for-each -loopilla.

\code{week3/basicexamples}{ForEachLoop}{For-each -loopin käyttö Javassa}

\subsection{While-looppi}
\label{while}

\newthought{While-looppi} on toistorakenne, jossa \java{for}-loopin tapaan sidotaan toistoehto
johonkin totuusarvoon, yleensä tietyn muuttujan suhteen. Toisin kuin for-loopissa, while loopissa
toisto ei tapahdu iterointimaisesti yhden muuttujan sijaan. Sen sijaan looppi luodaan
\newjava{while}-avainsanalla, jota seuraa loopin toistoehto sulkuihin suljettuna. Toistoehto
voi olla mikä tahansa totuusarvo ja looppia toistetaan niin kauan, kuin toistoehto on totta.
While-looppi on yleinen ohjausrakenteena ohjelman ytimessä: ohjelmaa tai ohjelman osaa ajetaan
niin kauan kuin ennalta määritelty ehto on totta. Seuraava koodiesimerkki esittelee while-loopin
käytön.

\code{week3/basicexamples}{BasicWhileLoop}{While-loopin käyttö Javassa}

\subsection{Do-while -looppi}
\label{do while}

\newthought{Välillä ilmenee} tarve käyttää while-loopin kaltaista toistorakennetta, mutta
tarkistaa toistoehdon totuusarvo vasta jokaisen toiston jälkeen. Tätä varten Javasta löytyy 
do-while -looppi. Looppi aloitetaan \newjava{do}-avainsanalla, jota seuraa saman tien loopin
runko suljettuna kaarisulkeisiin. Vasta rungon jälkeen määritellään toistoehto käyttämällä
\java{while}-avainsanaa, jonka jälkeen toistoehto suljetaan sulkeisiin. Looppi käyttäytyy
toistoehdon tarkastushetkeä lukuunottamatta tismalleen samoin kuin while-looppi. Yleisimmin tätä
looppia käytetään, kun halutaan loopin rungon tulevan ajetuksi ainakin kerran. Seuraava
koodiesimerkki esittelee tällaisen tilanteen: toistoehto on koko ohjelman ajan epätosi, mutta
loopin runko ajetaan kuitenkin kerran, koska toistoehto tarkastetaan vasta ajon jälkeen. Tämä ei
olisi mahdollista while-loopilla.

\code{week3/basicexamples}{DoWhileLoop}{Do while -loopin käyttö Javassa}

\subsection{Avainsanat break ja continue}
\label{break continue}

\newthought{Looppeja käyttäessä} on yleensä tarve ohittaa osa loopin rungon ajosta tai keskeyttää
loopin ajo ennen kuin toistoehto täyttyy tai iteroitava joukko on käyty kokonaan läpi. Esimerkiksi
hakuoperaatiossa on toivottavaa poistua toistorakenteesta heti kun toivottu alkio löytyy. Tätä
varten Javassa on kaksi avainsanaa: \newjava{break} ja \newjava{continue}. \java{break}-avainsana
keskeyttää loopin toistamisen ja poistuu toistorakenteesta, kun taas \java{continue} keskeyttää
yhden toiston ja aloittaa seuraavan toiston saman tien. Avainsanat mahdollistavat toistorakenteen
tarkemman ohjauksen. Seuraava esimerkki esittelee molempien avainsanojen käytön toistorakenteessa,
joka luettelee parillisia lukuja nollasta alkaen maxNumber-muuttujassa määriteltyyn
maksimiarvoon asti.

\code{week3/basicexamples}{BreakContinue}{Break- ja continue-avainsanojen käyttö Javassa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Javan ajamisen teoriaa}
\label{virtuaalikoneesta}

\newthought{Javan ajaminen} perustuu Javan virtuaalikoneeseen, joka luo ohjelmille oman pienen
hiekkalaatikon käyttöjärjestelmän sisällä ja standardoi täten ohjelmat alustasta riippumatta.
Tässä kappaleessa kurkataan hieman virtuaalikoneen toimintaan ja käyttöön ohjelmoijan
näkökulmasta.

\subsection{Tulkkaus vastaan kääntäminen}
\label{JIT}

\newthought{Ohjelmointikielet} voidaan jakaa karkeasti kahteen ryhmään sen mukaan, miten niillä
kirjoitettu ohjelma ajetaan. Jos kysessä on \neweng{tulkattu kieli}{intrepeted language},
ohjelmakoodia luetaan suoraan tekstitiedostosta ajon aikana tarpeen mukaan. Jos kyseessä on taas
\neweng{kaannetty kieli}{compiled language}, ohjelmakoodi kompiloidaan ennen ajoa. Java on
mielenkiintoinen tapaus tässä suhteessa, sillä Javaa ajettaessa ohjelmakoodi kompiloidaan
tavukoodiksi, jota Javan virtuaalikone ajaa. Tavukoodin ajotapa riippuu virtuaalikoneesta, mutta
yleensä Javan tavukoodin ajotekniikka on
\neweng{ajonaikainen kaantaminen}{Just-In-Time compiling}.

\newthought{Ajonaikainen kääntäminen} on ohjelman ajamissstrategia, jossa ennalta tuotettua
tavukoodia käännetää dynaamisesti ohjelman ajon aikana konekieliseen muotoon. Tämä eroaa
ratkaisevasti tulkkaamisesta, tarjoten paremman, lähes kääntämiseen verrattavan suorituskyvyn
pienen käynnistysviiveen kustannuksella. Lisäksi älykkäät kääntäjät voivat optimoida koodia
dynaamisesti ajon aikana. Lisäksi kaikkia tavukooditiedostoja ei tarvitse kääntää uudestaan aina,
kun koodia muokataan, joten iterointi on nopeampaa kuin aidoissa käännetyissä kielissä.

\newthought{Tämä tarkoittaa}, että Java-ohjelman kääntäminen ja ajaminen vie vähemmän aikaa, kuin
c:llä tai muulla käännettävällä kielellä. Ohjelman ajaminen ei kuitenkaan tapahdu saman tien niin
kuin tulkatulla kielellä, vaan bittikoodin kompilointi ja ajonaikaisen kääntämisen aloittaminen
vie hieman aikaa. Ajonaikaisen kääntämisen suorituskyky on lähellä käännettyjä kieliä, muttei ihan
samaa tasoa. Suorituskyky on kuitenkin huomattavasti parempi kuin tulkatuilla kielillä.

\subsection{Muistinhallinta ja garbage collector}
\label{GC}

\newthought{Mikäli olet} ohjelmoinut aiemmin vain pythonin kaltaisilla korkeamman tason kielillä,
muistinhallinta ei välttämättä ole tuttu asia. Myös Java abstraktoi korkean tason kielenä
muistinhallinnan pois käyttäjältä, joten toimivan ohjelman luominen ei vaadi muistinhallinnasta
välittämistä. Ohjelmojen optimoinnin kannalta on kuitenkin hyödyllistä ymmärtää muistinhallinnan
perusteet.

\newthought{Javan muistinhallinnan} pohjana on niin sanottu
\neweng{roskankeruu}{garbage collection}. Roskankeruun ideana on ajaa erillinen roskankeruuohjelma
tietyin väliajoin. Tämä ohjelma käy läpi muistissa olevat muuttujat ja tarkistaa jokaisen
muuttujan kohdalla, onko ohjelmassa aktiivisia viittauksia kyseiseen muuttujaan. Tämän jälkeen
ohjelma poistaa kaikki muuttujat, joihin ei ole olemassa aktiivisia viittauksia. Ohjelmien
suorituskyvyn parantaminen muistijalanjäljen suhteen onnistuu siis Javassa miettimällä tarkkaan,
miten laajalle alueelle muuttuja näkyy: funktion sisään rajoitettu muuttuja on huomattavasti
ystävällisempi muistinkäytön kannalta kun luokkaan tallennettu muuttuja.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lisää Javan konsepteja}
\label{loput perusteet}

\newthought{Tässä vaiheessa} opasta on käyty läpi onnistuneesti suurin osa Javan
peruskonsepteista. Reilusti yli kaksikymmentä vuotta vanhassa kielessä on kuitenkin valtava määrä
avainsanoja, konsepteja ja syntaksikikkoja. Seuraavat alakappaleet käsittelevät muutamia
tärkeimpiä konsepteja Javan käytössä. Moni avainsana jää tässä käsittelemättä, mutta suurin osa
ohjelmointikielien oletetusta ominaisuusjoukosta täyttyy seuraavien konseptien avulla.

\subsection{Valikkorakenne, switch ja case}
\label{switch}

\newthought{Mikäli ohjelmassa} ilmenee tarve valita useasta rinnakkaisesta vaihtoehdosta pitkä
ketju \java{if}- ja \java{else}-lauseita ei ole helpoin vaihtoehto. Javasta löytyy tällaiseen
tilanteeseen erillinen valikkorakenne, joka luodaan \newjava{switch}-avainsanalla. Avainsanaa
seuraa valikkorakenteen määritelmässä sulkuihin suljettu valintaehto. Valintaehdon jälkeen
seuraa itse valikkorakenteen runko kaarisulkuihin suljettuna. Runko koostuu haaroista, jotka
määritellään \newjava{case}-avainsanalla. Avainsanaa seuraa valintaehdon arvo, jolla haara
ajetaan. Jokainen haara lopetetaan yleensä \java{break}-avainsanaan, joka toistorakenteiden
tapaan poistuu valikkorakenteesta. Jos \java{break}-avainsana jätetään pois haaran lopusta,
valikko jatkaa seuraavaan haaraan, sopi valintaehto haaran ehtoon tai ei.

\newthought{Valikkorakenteen viimeiseksi} haaraksi kirjoitetaan yleensä oletushaara, joka
määritellää \newjava{default}-avainsanalla. Oletushaara ajetaan, mikäli mitään muuta haaraa ei
ajeta, tai mikäli haaraan jatketaan \java{break}-avainsanan puutteen vuoksi edellisestä haarasta.
Oletushaaraa voi käyttää esimerkiksi virhetilojen korjaamiseen. Seuraava koodiesimerkki esittelee
ohjelman, joka muuttaa valintarakenteella kouluarvosanan sanalliseksi arvioksi.

\code{week3/basicexamples}{Switch}{Valikkorakenne, \java{switch}- ja \java{case} -avainsanojen
käyttö Javassa}

\subsection{Luokkamuuttujat, luokkafunktiot ja static}
\label{static}

\newthought{Oppaassa viitattiin} aiemmin jo luokkamuuttujiin/-metodeihin kappaleessa
\nameref{main}. Luokkamuuttujat ja -metodit on sidottu ne omistavaan luokkaan luokan instanssin
sijasta. Kaikki luokan instanssit voivat käyttää luokkamuuttujia tai kutsua luokkametodeja, mutta
luokkametodin sisällä ei voi viitata instanssimuuttujaan, ainoastaan luokkamuuttujiin.
Luokkametodeja ja -muuttujia voidaan kutsua myös luokan nimen avulla pistenotaatiolla luokan
ulkopuolella. Esimerkiksi tulostamiseen käytetty \java{System}.out on oikeastaan luokkamuuttuja
out standardikirjaston System-luokassa.

\newthought{Luokkametodit ja -muuttujat} luodaan \newjava{static}-avainsanalla. Avainsanan
sijainti voi olla ennen tai jälkeen näkyvyysmääreen, mutta normalisoitu tyyli on kirjoittaa
näkyvyysmääre ennen static-avainsanaa. Main-metodi on siis luokkametodi ohjelman juuriluokassa.
Tämä tarkoittaa, ettei Javan tarvitse alustaa juuriluokan instanssia ohjelman ajon aluksi.
Seuraava esimerkki esittelee luokkametodin luomisen apuriluokkaan ja kutsumisen apuriluokan
ulkopuolelta ilman apuriluokan instanssia.

\code{week3/staticexample}{StaticPrinter}{Luokkametodin luominen \java{static}-avainsanalla}
\code{week3/staticexample}{Main}{Luokkametodin kutsuminen metodin määrittelevän luokan
ulkopuolella}

\subsection{Tyyppimuunnokset (casting)}
\label{casting}

\newthought{Staattisesti tyypitetyssä} kielessä voi olla välillä tarvetta vaihtaa tunnetun
muuttujan tyyppiä. Esimerkiksi lukuja käsiteltäessä saattaa olla tarvetta vaihtaa luvun tyyppi
kokonaisluvusta (\java{int}) liukuluvuksi (\java{float}) tai toisin päin. Java osaa vaihtaa
muuttujan tyypin automaattisesti, mikäli tavoitetietotyyppi on laajempi kuin alkuperäinen
tietotyyppi. Käytännössä esimerkiksi \java{int}-tyypin muuttuja voidaan aina muuttaa
\java{long}-tyypin muuttujaksi, koska \java{long}-tietotyyppi sisältää aina tarvittavan muistin
\java{int}-tyypin muuttujan säilömiseen. Kuitenkin välillä ei voida taata datan täydellistä
säilymistä. Tällöin Java vaatii ohjelmoijaa määrittelemään tyypinmuunnoksen manuaalisesti.
Tämän operaation nimi on \neweng{pakotettu tyypinmuunnos}{casting}.

\newthought{Pakotettu tyypinmuutos} tapahtuu sulkemalla toivottu tietotyyppi muunnettavan
muuttujan eteen sulkuihin. Java yrittää pakottaa muuttujan annettuun tietotyyppiin riippumatta
siitä, onko muutos mahdollista, joten pakotettu tyypinmuunnos huonosti harkitussa paikassa voi
aiheuttaa ongelmia ohjelman ajovaiheessa. Tyypinmuunnosta käsitellään tarkemmin periytymisen
yhteydessä. Seuraava koodiesimerkki esittelee tyyppimuunnoksen perussyntaksin muuttamalla
liukulukumuuttujan kokonaisluvuksi.

\code{week3/basicexamples}{Casting}{Tyyppimuunnos primitiivisestä tietotyypistä toiseen Javassa}

\subsection{Vakiot ja final}
\label{final}

\newthought{Monet ohjelmat} käyttävät vakioarvoja esimerkiksi asetusten tallentamiseen, tai
helpottamaan numeraalisten vakioiden lukemista koodissa. Javassa on tätä tarkoitusta varten
erillinen avainsana \newjava{final}. Final-avainsanalla määriteltyyn muuttujaan asetettua arvoa ei
voi enää muokata sen asettamisen jälkeen. Muuttujan voi määritellä final-avainsanalla asettamatta
sille arvoa. Tällöin ensimmäinen muuttujaan asetettu arvo jää vakioksi. Tämä on yleistä
määrittelemällä vakiomuuttuja luokan ruumiissa ja asettamalla sille arvo rakentajassa. Seuraava
koodiesimerkki esittelee final-avainsanan käytön perusteet.

\code{week3/basicexamples}{FinalUsage}{\java{final}-avainsanan käyttö Javassa}

\subsection{Luetellut tyypit (enum)}
\label{enum}

\newthought{Mikäli muuttuja} voi saada arvon vain jostain tarkasti rajatusta joukosta, kuten
ilmansuunnista, voi ensimmäisenä tulla mieleen kuvata näitä arvoja kokonaisluvuilla tai ennalta
määritellyillä merkkijonoilla. Molemmat tavat toimivat, mutta kokonaisluvut hankaloittavat koodin
lukemista, koska ohjelmoijan täytyy muistaa mitä arvoa mikäkin luku edustaa. Merkkijonot taas ovat
alttiita kirjoitusvirheille ja ovat hitaampia käsitellä ajon aikana. Tätä varten suurimmasta
osasta ohjelmointikieliä löytyy \neweng{lueteltu tyyppi}{enumerated type} -ominaisuus.

\newthought{Lueteltu tyyppi} luodaan Javassa korvaavalla luokan luomisessa \java{class}-avainsana
\newjava{enum}-avainsanalla. Yksinkertaisimmillaan lueteltu tyyppi sisältää vain kaikkien tyypin
mahdollisten arvojen määritelmät. Arvot nimetään yleensä CAPITAL\_CASE -nimeämistyylillä,
erotetaan toisistaan pilkulla ja erotellaan omille riveilleen. Arvoja voi käyttää joko
pistenotaatiolla arvoluokan nimestä tai jos lueteltu tyyppi on määritelty samassa nimitilassa
tai tuotu nimitilaan \java{import}-avainsanalla pelkällä arvon nimellä. Seuraavat koodiesimerkit
esittelevät luetellun tyypin luomisen ja käytön.

\code{week3/enumexample}{CompassPoint}{Lueteltu tyyppi ilmansuunnista}
\code{week3/enumexample}{Main}{Lueteltuun tyyppiin viittaaminen}

\subsection{Aritmeettiset- ja bittioperaatiot}
\label{operaatiot}

\newthought{Java sisältää} monia operaatioita lukujen ja tavumuotoisten tietojen käsittelyyn.
Seuraava taulukko esittelee Javan perusoperaatiot. Bittikohtaiset operaatiot Javassa ottavat
kaksi kokonaislukutyypin muuttujaa (\java{byte}, \java{short}, \java{int} tai \java{long}) ja
suorittavat kyseisen operaation luvun binääriesityksen jokaiselle bitille. Esimerkiksi luvut
kaksitoista (1100) ja kolme (0011) tuottaisivat bittikohtaisella TAI-operaatiolla tuloksen
viisitoista (1111).

\bigskip
\begin{center}
\footnotesize
\begin{tabular}{llll}
\toprule
Operaatio & Nimi & Toiminta & Esimerkki \\
\midrule
+ & summa & a + b & Laskee muuttujat a ja b yhteen \\
\addlinespace
- & erotus & a + b & Vähentää muuttujan b muuttujasta a \\
\addlinespace
* & tulo & a * b & Laskee muuttujien a ja b tulon \\
\addlinespace
/ & osamäärä & a / b & Laskee muuttujien a ja b osamäärän \\
\addlinespace
\% & modulo & a \% b & Laskee muuttujan a modulon (jakojäännös) jakajalla b \\
\addlinespace
++ & inkrementti & i++ & Kasvattaa kokonaislukumuuttujan i arvoa yhdellä \\
\addlinespace
-{}- & dekrementti & i-{}- & Vähentää kokonaislukumuuttujan i arvoa yhdellä \\
\addlinespace
== & on yhtä suuri kuin & a == b & Palauttaa tosi, jos a on yhtä suuri kuin b \\
\addlinespace
!= & on eri suuri kuin & a != b & Palauttaa tosi, jos a on eri suuri kuin b \\
\addlinespace
> & suurmepi kuin & a > b & Palauttaa tosi, jos a on suurempi kuin b \\
\addlinespace
< & suurmepi kuin & a < b & Palauttaa tosi, jos a on pienempi kuin b \\
\addlinespace
>= & suurmepi tai yhtä suuri kuin & a >= b & Palauttaa tosi, jos a suurempi tai yhtä
suuri kuin b \\
<= & pienempi tai yhtä pieni kuin & a <= b & Palauttaa tosi, jos a pienempi tai yhtä
pieni kuin b \\
\addlinespace
\& & bittikohtainen JA & a \& b & Palauttaa bittikohtaisen JA-operaation tuloksen luvuille a ja b
\\
\addlinespace
| & bittikohtainen TAI & a | b & Palauttaa bittikohtaisen TAI-operaation tuloksen luvuille a ja b
\\
\addlinespace
\^{} & bittikohtainen XTAI & a \^{} b & Palauttaa bittikohtaisen XTAI-operaation tuloksen luvuille
a ja b \\
\addlinespace
\~{} & Komplementti & \~{} a & Palauttaa a:n yhden komplementin \\
\bottomrule
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ensimmäinen esimerkkiohjelma: osoitekirja}
\label{osoitekirja}

\newthought{Opas on} nyt esitellyt kaiken tarvittavan Javasta simppelien ohjelmien
kirjoittamiseen. Normaalin ohjelman toiminnan, suunnittelun ja käytön esittelemiseksi tämän
kappaleen loppu omistetaan toimivalle koodiesimerkille. Koodiesimerkki sisältää
osoitekirjaohjelman, johon käyttäjä voi tallentaa kontaktidataa ja josta käyttäjä voi hakea dataa
kontaktin nimellä. Tämä esimerkki ei esittele uusia toiminnallisuuksia, joten sen voi halutessaan
ohitta ja jatkaa suoraan luvun \nameref{tiedostoista} alkuun. Esimerkki esittelee kuitenkin paitsi
Javan perusteiden toimintaa laajasti. Myös konkreettisia tapoja lähestyä oliopohjaisen ohjelman
suunnittelua ja toteuttamista, joten esimerkkiin tutustumista suositellaan lämpimästi.

\subsection{Osoitekirjaohjelman toimintaidea ja suunnittelu}
\label{osoitekirja suunnittelu}

\newthought{Ohjelman suunnittelu} on aina syytä aloittaa linjaamalla ohjelman tavoitteet. Tällä
kurssilla ei mennä sen tarkemmin projektinhallintaan, ketterään kehitykseen tai muihin metodeihin,
joten perustoimintaideoiden listaaminen riittää. Ohjelman perusvaatimukset ovat:

\begin{itemize}
	\item Ajettavissa komentoikkunassa
	\item Sisältää ikilooppiin perustuvan tekstipohjaisen käyttöliittymän
	\item Tallentaa puhelinnumeron nimetylle kontaktille
	\item Kykenee hakemaan käyttäjän puhelinnumeron nimen perusteella
\end{itemize}

\newthought{Listan perusteella} voidaan ruveta miettimään ohjelman rakennetta. Toivottu ikilooppi
voi sijaita pääluokassa ohjelman pienen koon ja yksinkertaisen luonteen vuoksi. Pääluokalle ei ole
järkevää kasata liikaa vastuita, sillä tämä vaikeuttaa ohjelman laajentamista tulevaisuudessa.
Olisi siis järkevää luoda luokka, joka hoitaa osoitekirjan manageroinnin. Pääluokka voi sitten
kutsua tätä luokkaa käyttäjän valintojen mukaan.

\newthought{Päätasolla ohjelman} arkkitehtuuri on siis pääluokka, jossa luodaan
AdressBookManager-luokan instanssi ja jonka main-metodi pyörittää ikuista looppia. Tämä 
manager-instanssi sisältää metodeja, jota pääluokasta voidaan kutsua käyttäjän valinnan mukaan.
Manageri tarvitsee ainakin metodit seuraaviin tarkoituksiin:

\begin{itemize}
	\item Kontaktin luominen: lisää nimi ja kontaktitiedot kontaktilistaan
	\item Kontaktin haku: Hae kontaktin tiedot listasta nimen perusteella
\end{itemize}

\newthought{Listasta nähdään}, että kontaktien hakeminen tapahtuu aina nimen perusteella. Tämä on
tärkeää ottaa huomioon kontakteja säilövää tietorakennetta suunnitellessa. \java{HashMap} on
rakenne, josta on nopea hakea tietoa avaimen perusteella, joten ContactManager voi säilöä
kontaktit \java{HashMap}-instanssiin, jossa on avaimena kontaktin nimi. Kontaktidataa varten
voitaisiin luoda uusi luokka puhdasta datan säilömistä varten, mutta koska data koostuu kahdesta
arvosta, joista toinen säilötään avaimena hajautustauluun, on järkevämpää tallentaa data vain
puhelinnumerona avain-arvo -parin arvoksi.

\newthought{Täten esimerkki} koostuu kahdesta luokasta. AddressBook on pääluokka, joka sisältää
ohjelman elossa pitävän ikiloopin, joka lukee käyttäjäsyötettä ja kutsuu niiden mukaan metodeja
ContactManager-luokasta. ContactManager sisältää metodeja osoitekirjan manipulointiin ja
itse osoitekirjan hajautustaulussa, jonka avaimia ovat merkkijonomuotoiset kontaktien nimet ja
arvoja merkkijonomuotoiset puhelinnumerot. Puhelinnumeroiden säilöminen kokonaislukuna törmää
kahteen ongelmaan. Maakoodien säilöminen ei olisi mahdollista ja nollalla alkavat numerot
typistyisivät alusta.


\subsection{Osoitekirjaohjelman koodi}
\label{osoitekirja koodi}

\code{week3/addressbookexample}{ContactManager}{Osoitekirjamanageri osoitekirjan hallintaan}
\code{week3/addressbookexample}{AddressBook}{Pääluokka, joka vastaa ohjelman ajamisesta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Tiedostonhallinta ja virheenkäsittely}
\label{tiedostoista}

\newthought{Tähän mennessä} oppaassa on käyty läpi suurin osa Javan perustoiminnasta ja kerrytetty
tarvittava tietotaito simppelien ohjelmistojen luomiseen. Opas ei kuitenkaan ole vielä tarjonnut
ratkaisuja pysyvään datan säilömiseen, joten kaikki ohjelmien käsittelemä data kuolee ohjelmien
ajon päätyttyä. Tässä kappaleessa tutustutaan yksinkertaisimpaan tapaan säilöä dataa pysyvästi:
tiedostonhallintaan. 

\newthought{Linux-maailmasta tuttuun} tapaan Javassa tiedostonhallinta muistuttaa vahvasti
käyttäjäsyötteen käsittelyä. Tiedostojen lukeminen tapahtuu \newjava{FileReader} tai
\newjava{FileInputStream} -olioilla ja tiedostoon kirjoittaminen \newjava{FileWriter} tai
\newjava{FileOutputStream} -olioilla. Seuraavat kappaleissa käydään läpi näiden luokkien käyttö,
sekä olioiden \neweng{serialisaatio}{serialization}, joka mahdollistaa olioiden esittämisen
tekstimuotoisena datana, ja täten olioiden tallentamisen tekstitiedostoihin. Tätä ennen käydään
läpi javan virheenkäsittely, sillä se on olennainen osa tiedostojen turvallista käsittelyä.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Virheenkäsittelyn perusteet, try-catch-finally}
\label{try-catch}

\newthought{Java sisältää} monipuolisen virhetilajärjestelmän virheenkäsittelyä varten. Virhetilat
esitetään Exception-luokasta perittyinä erityyppisinä Exception-instansseina. Esimerkiksi jos
ohjelmisto yrittää hakea tietoa muuttujasta, jossa on säilötty vain null-arvo, nostaa Java
automaattisesti NullPointerException-virheen. 

\newthought{Virheiden käsittely} tapahtuu sulkemalla virhetilan mahdollisesti aiheuttava koodi
\newjava{try}-avainsanalla määritellyn kaarisulkeisiin suljetun koodin osan sisään. Tätä seuraa
virhetilan käsittely, joka määritellään \newjava{catch}-avainsanalla, jota seuraa sulkeissa
kiinniotettavan virheen määrittely, eli virheluokka, jonka instanssit otetaan kiinni ja
muuttujanimi, johon virheluokan ilmentymät kiinnitetään. Tätä määritelmää seuraa itse virhetilan
korjaus suljettuna kaarisulkeisiin. Tämä korjausosio ajetaan vain, jos \java{try}-osassa tapahtuu
sulkeissa määritellyn tyypin virhe. Viimeinen virheenkäsittelyrakenteen osa on
\newjava{final}-avainsanaa seuraava kaarisulkeisiin suljettu yleinen sulkemiskoodi, joka ajetaan,
tapahtui \java{try}-rakenteessa virhettä tai ei. Rakenteen ei tarvitse sisältää sekä \java{catch}-
että \java{finally}-osioita, mutta vähintään toisen on oltava \java{try}-rakenteen perässä tai
koodi ei käänny. Seuraava koodiesmerkki esittelee virheenkäsittelyn perusteet.

\code{week4}{BasicTryCatchFinally}{\java{try}-, \java{catch}- ja \java{finally}-avainsanojen
käyttäminen}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{FileReader ja FileWriter}
\label{tiedostoapureista}

\newthought{\java{FileReader} ja \java{FileWriter}} ovat merkkijonomuotoisten tiedostojen
käsittelyyn tarkoitettuja apuriluokkia. \java{FileReader} sisältää read-metodin datan lukemiseen
ja \java{FileWriter} sisältää write- ja append -metodit datan kirjoittamiseen. Sekä lukeminen,
että kirjoittaminen voi epäonnistua ohjelmistosta riippumattomista syistä. Tästä syystä nämä
operaatiot on järkevää sulkea edellä esitellyn \java{try}-rakenteen sisään. 

\newthought{Syötteen lukemisen} tapaan, tiedostojen lukeminen suoraan lukijalla tapahtuu merkki
kerrallaan. On siis järkevää sulkea \java{FileReader} \java{BufferedReader}-instanssin sijaan,
kuten kappale \nameref{syötteestä} esittelee. Seuraava esimerkki esittelee tekstimuotoisen datan
käsittelemisen tiedostoissa luomalla ensin tiedoston ja tallentamalla merkkijonon tähän tiedostoon
ja lukemalla sen jälkeen tallennetun merkkijonon tiedostosta \java{BufferedReader}-instanssin
sisään kiedotulla \java{FileReader}-instanssilla.

\code{week4}{BasicFileWriterReader}{Merkkijonodatan käsittely tiedostoissa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{FileInputStream ja FileOutputStream}
\label{tiedostostreameista}

\newthought{Tiedostot eivät} aina sisällä merkkimuotoista dataa. Tätä varten on olemassa luokat
\java{FileInputStream} ja \java{FileOutputStream}. Ne käsittelevät tiedostoon suljettua
tavumuotoista dataa samaan tapaan kuin \java{InputStreamReader} lukee käyttäjäsyötteestä
tavumuotoista dataa. Toisin kuin \java{FileReader}, ei \java{FileInputStream}-luokkaa tarvitse
kääriä \java{BufferedReader}-luokan sisään. Seuraava koodiesimerkki esittelee tavumuotoisen datan
käsittelyn tiedostossa.

\code{week4}{BasicFileInputOutputStream}{Tavumuotoisen datan käsittely tiedostoissa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Oliopohjainen suunnittelu}
\label{suunnittelusta}

\newthought{Oppaassa on} nyt käyty läpi suurin osa Javan perusominaisuuksista. Kurssin tavoitteena
ei ole kuitenkaan opettaa opiskelija ohjelmoimaan Javaa, vaan opettaa opiskelijalle
olio-ohjelmoinnin käytänteet. Tämän luvun tavoitteena on avata olio-ohjelmoinnin mahdollistamia,
sekä muita sille yleisiä suunnittelumalleja. Tällä tavalla luku pyrkii antamaan alkuoppaan vakaan
käytännön pohjan lisäksi laajan teoriapohjan olio-ohjelmointia aloittevalle opiskelijalle.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Aggregaatio ja kompositio}
\label{aggregaatiokompositio}

\newthought{Oliopohjaisen suunnittelun} osana joudutaan usein puhumaan luokkien välisistä
suhteista, erityisesti, miten luokat viittaavat toisiin luokkiin ja miten näiden luokkien
instanssien elinkaaret ohjelmassa eroavat toisistaan. Tätä kuvaavat käsitteet
\neweng{aggregaatio}{aggregation} ja \neweng{kompositio}{composition}. Molemmat ovat
omistussuhteita, eli suhteita, joissa luokan A instanssi viittaa luokan B instanssiin "omistaen"
tämän.

\subsection{Aggregaatio}
\label{aggregaatio}

\newthought{\Gls{aggregaatio} on} luokkien välinen omistussuhde, jossa luokan A instanssi omistaa
luokan B instanssin väliaikaisesti. Omistettu instanssi siis luodaan muualla ja ei tuhoudu
omistavan instanssin mukana. Tällainen rakenne on yleistä kokoelmapohjaisissa rakenteissa.
Esimerkiksi mallinnettaessa linja-autoa oliopohjaisilla käsitteillä, linja-auto -luokan ja
matkustaja-luokan välinen suhde olisi aggregaatio: matkustaja on olemassa ennen suhteen luomista
ja ei tuhoudu suhteen tuhouduttua.

\subsection{Kompositio}
\label{kompositio}

\newthought{Gls{kompositio} on} luokken välinen omistussuhde, jossa luokan A instanssi omistaa
luokan B instanssin pysyvästi, niin, että instanssien elinajat on sidottu toisiinsa. Luokan B
instanssi luodaan sen omistavan luokan A instanssin mukana ja tuhoutuu tämän instanssin kanssa.
Täten luokan B instansseja ei voi olla olemassa erillään ne omistavasta luokan A instanssista,
eikä luokan A instansseja ilman niiden omistamia luokan B instansseja. Tälläinen suhde on yleistä
suurien komponenttien erillisessä luokassa esitettyjen osien kanssa. Esimerkiksi aggregaation
yhteydessä annetussa linja-auto -esimerkissä linja-auto -luokan ja moottori-luokan välinen suhde
on kompositiosuhde. Moottori luodaan linja-auton kanssa ja tuhoutuu kun linja-auto tuhoutuu.
Kompositiossa siis omistettu luokka on vain yksi rakennuspalikka omistavan luokan osana.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Periytymisen alkeet}
\label{periytyminen1}

\newthought{Yksi laadukkaan} ohjelmiston tärkeimmistä piirteistä on turhan toiston poistaminen
koodista. Tarkastellaan esimerkkinä pankin tilinhallintaa. Pankit tarjoavat monesti erilaisia
tilejä eri käyttötarkoituksiin. Käyttötili, säästötili ja yrityksen tili kaikki todennäköisesti
tarvitsevat eri tietokenttiä ja metodeja täyden toiminnallisuutensa toteuttamiseen. Kun jokaiselle
näistä kolmesta tilityypistä luodaan oma luokkansa huomataan kuitenkin luokkien sisältävän
itseään toistavaa koodia. Kaikilla luoduilla luokilla on oltava tietokentät tilinumerolle,
saldolle ja omistajan kontaktitiedoille. Lisäksi jokaiselta luokalta löytyy todennäköisesti
metodit tilin saldon tarkastamiseen ja panon ja noston suorittamiseen. Turhan toiston
eliminoimiseksi tarvitaan siis rakenne, joka antaa luokkien käyttää samaa pohjaa, mutta muokata
omaa toiminnallisuuttaan tämän pohjan päällä. Tätä varten oliopohjaiset kielet tarjoavat
ominaisuuden, nimeltä \neweng{periytyminen}{inheritance}

\newthought{Periytymisen perusidea} on mahdollistaa luokkien toiminnallisuuksien uudelleenkäyttö
ja laajentaminen. Tämä tapahtuu luomalla niin sanottu \neweng{lapsiluokka}{child class}
laajennettavasta luokasta. Tällä tavalla laajennettua luokkaa sanotaan luodun lapsiluokan
\neweng{kantaluokka}{parent class}.

\newthought{Lapsiluokka perii} kaikki kantaluokan ominaisuudet ja kykenee muokkaamaan niitä tai
lisäämään uusia, omia ominaisuuksiaan. Esimerkiksi pankkiohjelmistoa luotaessa voitaisiin kaikki
erilaiset tilit toteuttaa luomalla normaalia käyttötiliä kuvaava Account-niminen kantaluokka.
Tämän jälkeen säästötili ja yritystili voidaan esittää tästä kantaluokasta periytyvinä
lapsiluokkina. Kantaluokka voi sisältää esimerkiksi tietokentät tilinumerolle, tilin saldolle ja
tilin omistajan kontaktitiedoille. Näiden lisäksi kantaluokalla voi olla metodeja. Account-luokka
esimerkiksi voi sisältää metodin nostoille ja panoille, sekä metodin tilin saldon tarkastamiseen.
Lapsiluokat voivat tarpeen vaatiessa ylikirjoittaa näitä metodeja vastaamaan omaa toimintaansa.
Esimerkiksi säästötilin nostometodiin voidaan lisätä ehto, jossa sitä voi käyttää vain tietyin
väliajoin. Myös uusien kenttien ja metodien lisääminen lapsiluokkaan on mahdollista. Esimerkiksi
yritystilille voidaan lisätä tietokenttä tallentamaan yrityksen nimi ja edellä mainitulle
säästötilille voidaan lisätä metodi kerryttämään korkoa.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{UML}
\label{paskaa}

\newthought{Välillä ohjelmiston} suunnittelun yhteydessä ilmenee tarve esittää ohjelmiston
luokkien välisiä suhteita tarkemmin ja selkeämmin kuin sanallisesti on mahdollista. Tätä varten on
olemassa \neweng{UML}{Unified Modeling Language}. Se on ohjelmistotuotantoa varten kehitetty
standardi, joka sisältää useita ohjelmistojen suunnittelussa käytettäviä kaavioita. Tässä oppaassa
käsitellään näistä vain \neweng{luokkakaavio}{class diagram}, sillä se on ehdottomasti tärkein
kaaviotyyppi oliopohjaisen ohjelman suunnittelussa. Muita UML-standardissa määriteltyjä
kaaviotyyppejä ovat muun muassa oliokaavio, tilakaavio ja sekvenssikaavio.

\subsection{Luokkakaavio}
\label{luokkakaavio}

\newthought{\gls{UML}-standardin tapa} ilmaista luokkien välisiä suhteita on \gls{luokkakaavio}
ohjelmistossa. Kaavio suunniteltiin alun perin tarpeeksi tarkaksi koodin generointiin kaavion
pohjalta, mutta nykyään kaavion yleisimmin hyväksytty käyttötapa on suunnitteluvaiheessa ideoiden
kommunikointi ohjelmiston suunnittelijoiden välillä.

\newthought{Luokkakaavio koostuu} luokkia kuvaavista suorakulmion muotoisista soluista ja niiden
välisistä yhteyksistä. Solu jakautuu yleensä kolmeen osaan. Ylimpänä on solun kuvaaman luokan
nimi, sen jälkeen luokan tietokentät ja alimpana luokan metodit. Tietokenttien ja metodien
yhteyteen voidaan lisätä tyyppidata, mutta se ei ole pakollista ja riippuu kaavion
käyttötarkoituksesta. Seuraava kuva esittää yksinkertaisen luokan kuvauksen luokkakaaviossa.
Luokan nimi on DataManipulator, se omistaa int-tyypin tietokentän integerDataPoint ja
String-tyypin tietokentän stringDataPoint sekä metodin ManipulateData, joka ottaa int- ja
String-tyyppien muuttujat ja palauttaa String-tyypin muuttujan.

\begin{listing}
    \includegraphics{ClassDiagramExample1}
    \caption{Yksittäisen luokan esittäminen UML-luokkakaaviossa}
    \label{luokkakaavioluokka}
\end{listing}

\newthought{Luokkakaaviossa ohjelmiston} erilaisten luokkien esittäminen on kuitenkin vain pieni
osa kaavion käyttöä. Tärkein luokkakaavion käyttötarkoitus on luokkien välisten suhteiden
esittäminen ohjelmistossa. Luokkakaavio sisältää näiden suhteiden kuvaamiseen erilaisia
yhteystyyppiä, joita luokkien välille voidaan piirtää. Näistä käytetyimmät ovat yleistä
assosiaatiota, periytymistä, aggregaatiota ja kompositiota kuvaavat yhteydet. Yhteyden tarkka
tyyli riippuu kaavionpiirto-ohjelmasta. Yleensä assosiaatiota kuvaava yhteys on yksinkertainen
viiva luokkien välillä, periytymistä kuvaava yhteys on nuoli lapsiluokasta emoluokkaan ja
aggregaatiota ja kompositiota kuvaavat yhteydet ovat viivoja, jotka päättyvät vinoneliöön
omistussuhteen omistavan osapuolen päässä. Aggregaatiossa vinoneliö on täyttämätön,
kompositiossa täytetty. Seuraava kaavio esittelee kaikki neljä yhteystyyppiä.

\begin{listing}
    \includegraphics{ClassDiagramExample2}
    \caption{Luokkien välisten suhteiden esittäminen UML-luokkakaaviossa}
    \label{luokkakaavioluokka}
\end{listing}

\subsection{Kaavioiden käyttö ohjelmiston suunnittelussa}
\label{UMLkäyttö}

\newthought{\gls{UML} kehitettiin} alun perin aikakaudella, jolloin vesiputousmallia pidettiin
erinomaisena vaihtoehtona ohjelmistoprojektin projektinhallintamalliksi ja ketterä kehitys oli
täysin tuntematon käsite. Tällöin ohjelmiston täydellisen rakenteen mallintamisen UML-kaavioilla 
ajateltiin olevan järkevä tapa suunnitella ohjelmistoja. Modernissa ohjelmistokehityksessä
vesiputousmalli on kuitenkin pudonnut pois suosiosta ja se on korvattu lähinnä ketterän kehityksen
innoittamilla projektinhallintametodeilla, kuten Scrum ja XP. Täten myös UML-kaavioiden rooli
osana ohjelmitonkehitysprosessia on modernisoitunut. Yleinen vallitseva käsitys alalla on, että
kaavioiden ei pitäisi olla yleisessä käytössä, vaan niitä kuuluisi käyttää vain nopeaan
ohjelmiston mallintamiseen erityisesti tehtäessä yhteistyötä usean kehittäjän kesken.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Periytyminen ja Java}
\label{periytyminen2}

\newthought{\Gls{periytyminen} käsitteenä} käytiin läpi viime luvussa, mutta sen soveltaminen
käytännön ohjelmistotuotantoon jätettiin käsittelemättä. Tämän luvun tavoitteena on opettaa
periytymisen käyttö Javassa ja samalla syventyä periytymisen hyötyihin ja haittoihin, sen
oikeaoppisiin käyttökohteisiin ja teoriaan periytymisen takana.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Periytymisen perusteet ja extends}
\label{periytyminen3}

\subsection{Avainsana extends}
\label{extends}

\newthought{Javassa \gls{periytyminen}} toteutetaan \newjava{extends}-avainsanan avulla. Avainsana
sijoitetaan lapsiluokan määritelmään luokan nimen perään, niin että toivotun kantaluokan nimi
seuraa avainsanaa. Tämän jälkeen luokan määritelmää jatketaan normaalisti. Seuraava koodiesimerkki
esittelee yksinkertaisen periytymiseen pohjaavan rakenteen luomisen Javassa.

\code{week6/basicinheritanceexample}{Parent}{Periytymisesimerkin kantaluokka}
\code{week6/basicinheritanceexample}{Child}{Periytymisesimerkin lapsiluokka}
\code{week6/basicinheritanceexample}{Main}{Periytymisesimerkin pääluokka}

\subsection{Kantaluokan toiminnallisuuksien uudelleenmäärittely}
\label{overriding}

\newthought{Aina ei} ole toivottavaa, että lapsiluokka perii kaiken kantaluokan toiminnallisuuden.
Tätä varten Java tarjoaa mahdollisuuden uudelleenmääritellä periytettyjen luokkien perimiä
metodeja. Tämä metodin \neweng{korvaaminen}{overriding} tapahtuu yksinkertaisesti määrittelemällä
lapsiluokassa metodi, jonka \gls{signatuuri} on tismalleen sama, kuin kantaluokan korvattavan
metodin. Tällöin kutsuttaessa lapsiluokan metodia kyseisellä signatuurilla ajetaan lapsiluokassa
määritelty versio metodista. Seuraava koodiesimerkki esittelee metodin toiminnan korvaamisen
käytännössä.

\code{week6/overridingexample}{Parent}{Korvaamisesimerkin kantaluokka}
\code{week6/overridingexample}{Child}{Korvaamisesimerkin lapsiluokka}
\code{week6/overridingexample}{Main}{Korvaamisesimerkin pääluokka}

\section{Periytyminen ja rakentajat}
\label{superprotected}

\subsection{Näkyvyysmääre protected}
\label{protected}

\newthought{Aiemmin oppaan} kappaleessa \nameref{näkyvyysmääreet} käytiin läpi käsite
\gls{nakyvyysmaare} ja avainsanat \java{public} ja \java{private}. Näiden ja oletusnäkyvyyden
lisäksi Javassa on olemassa neljäs näkyvyysmääreavainsana \newjava{protected}. Avainsana määrittää
muuttujan tai metodin olevan näkyvissä vain luokalle itselleen, sekä kaikille luokan periville
luokille. Näkyvyysmääreen \java{private} omaava muuttuja tai metodi ei siis näy edes luokan
periville luokille.

\subsection{Periytyminen, rakentajat ja super}
\label{super}

\newthought{Luotaessa lapsiluokan} instanssia Javassa on aina kutsuttava kantaluokan rakentajaa.
Mikäli kummallekaan luokalle ei ole määritelty rakentajaa, kutsuu Java automaattisesti kantaluokan
oletusrakentajaa rakentaessaan lapsiluokan instanssia. Mikäli lapsiluokalla ei ole rakentajaa,
mutta kantaluokalle halutaan määrittää rakentaja, jota lapsiluokan rakennus käyttää, on tämän
rakentajan oltava parametritön.

\newthought{Mikäli lapsiluokalle} luodaan itse määritelty rakentaja, on rakentajan kutsuttava
ensimmäisenä komentona jotain emoluokan rakentajaa. Tämän ei tarvitse olla parametritön
oletusrakentaja vaan mikä tahansa rakentaja kelpaa.

\newthought{Päästäkseen käsiksi} kantaluokkansa kenttiin, kuten rakentajiin, voi lapsiluokka
käyttää \newjava{super}-avainsanaa. Avainsana toimii viittauksena kantaluokan instanssiin, jonka
pohjalle lapsiluokka on luotu. Käyttämällä avainsanaa metodikutsuna päästään käsiksi kantaluokan
rakentajametodin eri ylikuormituksiin ja käyttämällä pistenotaatiota päästään käsiksi kantaluokan
muuttujiin ja metodeihin näkyvyysmääreiden salliessa. Seuraavat koodiesimerkit esittelevät
rakentajien käytön periytymisen yhteydessä, sekä avainsanat \java{super} ja \java{protected}

\code{week6/inheritancewithconstructors}{ParentWithoutConstructor}{Rakentajaton kantaluokka}
\code{week6/inheritancewithconstructors}{ChildOfConstructorless}{Rakentajattoman kantaluokan
lapsiluokka, jolle on määritelty rakentaja}
\code{week6/inheritancewithconstructors}{ParentWithConstructor}{Kantaluokka, jolla on rakentaja}
\code{week6/inheritancewithconstructors}{ChildOfConstructorParent}{Rakentajallisen kantaluokan
lapsiluokka, jolle on määritelty erillinen rakentaja}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Periytymisen oikeaoppinen käyttö}
\label{periytyminen4}

\newthought{Periytyminen on} monimutkainen rakenne joka tarjoaa ohjemoijalle voimakkaan työkalun.
Tätä työkalua on helppo käyttää väärin mikäli periytymistä lähdetään käyttämään kaikkialla ja
siitä yritetään tehdä ratkaisu joka ongelmaan. Periytymiselle on oma paikkansa ohjelmiston
suunnittelussa ja se ratkaisee jotkin ongelmat erinomaisesti, mutta on olemassa tiettyjä
lainalaisuuksia, jotka on pidettävä mielessä periytymistä hyödynnettäessä. Näin varmistetaan, että
ohjelmiston kehittäminen helpottuu periytymisrakenteiden vaikutuksesta, sen sijaan että
kehittämisprosessia monimutkaistettaisiin turhaan ilman selkeitä hyötyjä periytymisestä.

\subsection{Liskovin korvaavuusperiaate}
\label{LSP}

\newthought{Kuten kapppaleen} \nameref{super} koodiesimerkeissä nähtiin, voidaan lapsiluokan olio
tallentaa muuttujaan, jonka tyypiksi on määritelty emoluokan olio. Tällöin muuttujaan tallennettua
olioita voidaan kohdella kuin emoluokan oliota. Tämä käyttäytyminen mahdollistaa monia hyödyllisiä
toiminnallisuuksia, kuten monen eri lapsiluokan instanssien tallentamista samaan \java{ArrayList}-
instanssiin, kunhan kyseinen \java{ArrayList}-instanssi on geneerinen kantaluokan yli, eikä
jonkin lapsiluokan yli.

\newthought{Kuitenkin tällainen} luokkien käyttäminen luo velvotteita lapsiluokkien suunnitteluun.
Jotta edellä kuvailtu käyttötapa sujuisi ongelmitta, kuuluu lapsiluokkien ja emoluokan toteuttaa
\neweng{Liskovin korvaavuusperiaate}{Liskov Substitution Principle - LSP}. Periaate on osa
viiden periaatteen muodostamaa \neweng{SOLID-periaatteet}{SOLID-principles} -ryhmää. Periaatteet
on suunniteltu helpottamaan laadukkaan oliopohjaisen koodin tuottamista ja loput periaatteet
käsitellään myöhemmin luvussa \nameref{solid}.

\newthought{\Gls{Liskovin korvaavuusperiaate}} määrittelee kantaluokan ja lapsiluokkien suhteen
seuraavasti: "Mikä tahansa emoluokan instanssi pitäisi olla korvattavassa millä tahansa 
lapsiluokan instanssilla ilman että ohjelman toiminta häiriintyy." Käytännössä tämä tarkoittaa,
että lapsiluokkien ei pitäisi ylikirjoittaa emoluokkien julkisia kenttiä niin että kentän
toiminnallisuus ulkoa tarkasteltaessa muuttuu. Esimerkiksi metodin ylikirjoittaminen
toimimattomalla tyngällä rikkoo täten Liskovin korvaavuusperiaatetta.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Periytymisen rakenteita}
\label{periytyminen5}

\newthought{Tähän mennessä} oppaassa on käsitelty vain suoraa periytymistä, jossa
\gls{kantaluokka} ja \gls{lapsiluokka} ovat molemmat normaaleja Javan luokkia. Periytyminen on
kuitenkin rakenne, jota käytetään monimutkaisten teollisten ohjelmien suunnittelussa ja täten
suurimpaan osaan oliopohjaisia kieliä on kehitetty rakenteita periytymiseen pohjaavan
arkkitehtuurin siistimiseen. Näistä tärkeimmät ovat \neweng{abstrakti luokka}{abstract class} ja
\neweng{rajapinta}{interface}. Tämä kappale käy läpi näiden rakenteiden käytön koodissa ja niiden
käyttötarkoitukset, sekä puhuu hieman rakenteiden eroista.

\subsection{Abstrakti luokka}
\label{abstract}

\newthought{\Gls{abstrakti luokka}} on oliopohjainen rakenne, jossa luokan määritelmästä tehdään
pelkkä muotti, jonka ainoa tehtävä on toimia pohjana kyseisestä luokasta periytyville
lapsiluokille. Tällaisen rakenteen tehtävänä on varmistaa että jokainen luokka, joka periytyy
abstraktista kantaluokasta toteuttaa jonkin jaetun toiminnallisuuden ja samalla estää kantaluokan
suora käyttäminen koodissa, koska sen ei kuulukaan tietää miten tämän toiminnallisuuden 
implementaatio tapahtuu. Luokasta tehdään abstrakti lisäämällä \newjava{abstract}-avainsana luokan
määritelmään \java{class}-avainsanan eteen. Abstraktin luokan ei-abstraktin lapsiluokan nimi on
\neweng{konkreettinen luokka}{concrete class}.

\newthought{Jokaisella abstraktilla} luokalla on oltava vähintään yksi 
\neweng{abstrakti metodi}{abstract method}. Tämä metodi määritellään luomalla metodi, joka
sisältää pelkän signatuurin ilman runkoa ja lisäämällä metodin määritelmään \java{abstract}
-avainsana näkyvyysmääreen jälkeen. Abstrakti metoodi on siis ikään kuin musta laatikko. Sen
argumentit ja paluuarvo tiedetään, mutta abstrakti kantaluokka, joka määrittelee metodin ei
kerro, miten metodeista saadaan paluuarvo vaan jokaisen konkreettisen lapsiluokan on
määriteltävä tämä itse.

\newthought{Abstraktin luokan} käyttö koodissa vaatii yleensä jonkin jaetun toiminnallisuuden
tarpeen toteamista ja tämän toiminnallisuuden eristämistä abstraktiin luokkaan. Seuraava
koodiesimerkki esittelee abstraktin kantaluokan ja konkreettisen lapsiluokan luomisen. Esimerkissä
luodaan "AbstractLogger"-kantaluokka, joka sisältää \java{protected}-metodin "formatLogString" ja
abstraktin julkisen metodin "logString". Sen jälkeen kantaluokasta tehdään konkreettinen
lapsiluokka "CommandLineLogger", joka sisältää määritelmän kantaluokan "logString"-metodille.
Huomaa, kuinka lapsiluokka pystyy käyttämään "formatLogString"-metodia, joka on määritelty
kantaluokassa.

\code{week6/abstractexample}{AbstractLogger}{Abstrakti loggaajapohja}
\code{week6/abstractexample}{CommandLineLogger}{Loggaajaan konkreettinen implementaatio, joka
tulostaa saadun tekstidatan komentoriville}

\subsection{Rajapinta}
\label{interface}

\newthought{Toinen tapa} eristää luokkien jakamaa toiminnallisuuttaa koodissa on rajapintaluokka,
joka luodaan \java{interface}-avainsanalla. Rajapintaluokan tehtävä on luokan nimen mukaisesti
määrittää jokin \gls{rajapinta} jonka muut ohjelmiston luokat voivat sitten ilmoittaa täyttävänsä.
Toisin kuin \gls{abstrakti luokka}, rajapintaluokka voi sisältää ainoastaa julkisia ja staattisia 
vakiotietokenttiä, eikä rajapintaluokkaa voi käytää kantaluokkana periytymisessä. Tämän sijaan
mikä tahansa ohjelmiston luokka voi ilmoittaa, että se \neweng{toteuttaa}{implement}
rajapintaluokan. Luokan, joka toteuttaa rajapintaluokan on määriteltävä jokainen rajapinnassa
määritelty metodi. Näistä määritelmistä jokaisella pitää olla identtinen \gls{signatuuri}
rajapintaluokan vastaavan metodin määritelmän kanssa.

\newthought{Rajapintaluokka määritellään} Javassa korvaamalla normaalin luokan määritelmän 
\java{class}-avainsana \newjava{interface}-avainsanalla. Rajapintaluokkasta ei voi luoda
instansseja, eikä luokalle voi määrittää rakentajaa. Ainoat tietokentät, jotka ovat hyväksyttyjä
rajapintaluokassa ovat oletuksena näkyvyydeltään julkisia luokkamuuttujavakioita. Mikäli muuttujan
määritelmä rajapintaluokassa ei sisällä avainsanoja \java{public}, \java{static} ja \java{final}
lisätään ne määritelmään automaattisesti. Muiden näkyvyysmääreiden käyttäminen estää ohjelmiston
rakentamisen.

\newthought{Rajapintaluokan kaikki} metodit ovat automaattisesti abstrakteja metodeja. Myös
metodien on oltava rajapintaluokassa julkisia muuttujien tapaan. Java tukee metodin
oletustoiminnallisuuden määrittelemistä \newjava{default}-avainsanalla, mutta mikäli ohjelmiston
kehitysvaiheessa huomataan tälle olevan tarvetta kannattaa miettiä tarkkaan, käytetäänkö
rajapintaluokkaa oikein; Avainsana on olemassa lähinnä mahdollistamaan myöhemmät laajennukset
yleisesti käytettyihin rajapintoihin eikä siihen kannata tukeutua. Tästä syystä oppaassa ei
myöskään käydä avainsanan käyttöä tämän tarkemmin läpi.

\newthought{Seuraava koodiesimerkki} esittelee simppelin "TextProvider"-rajapinnan luomisen ja
kyseisen rajapintaluokan implementoimisen konkreettiseen luokkaan.

\code{week6/interfaceexample}{TextProvider}{TextProvider rajapintaluokka}
\code{week6/interfaceexample}{FunctionalClass}{Luokka, joka implementoi TextProvider-rajapinnan}

\subsection{Rajapinta vai abstrakti luokka?}
\label{interface v abstract}

\newthought{Rajapintaluokka ja} abstrakti luokka muistuttavat toisiaan toiminnallisuuksiltaan ja
osin käyttötavoiltaankin. Niille molemmille löytyvät kuitenkin omat erilliset käyttökohteensa ja
syvempi ymmärrys luokkatyyppien toiminnallisuuksien eroista auttaa käsittämään nämä erilaiset
käyttökohteet.

\newthought{Koska Java} \neweng{moniperinta}{multiple inheritance} ei ole tuettua Javassa, ei
abstrakteja luokkia voi käyttää lisäämään yhdelle luokalle useamman eri luokan toiminnallisuuksia.
Tällainen on rajapintaluokkien tehtävä. Sen sijaan abstrakti luokka voi määritellä valmiiksi
toiminnallisuuksia ja datakenttiä itselleen, helpottaen lapsiluokkien kirjoittamista. Abstraktin
luokan pääkäyttötarkoitus onkin luoda koodiin jokin palvelu, kuten logien kirjoittaminen, jonka
yleinen toiminnallisuus on tiedossa, mutta toteutus riippuu käytettävästä kirjastosta. Esimerkiksi
tässä logiesimerkissä, voitaisiin luoda abstrakti luokka, jolle implementoidaan valmiiksi funktiot
logien muotoiluun, mutta jonka loginkirjoitusfunktiot määritellään abstrakteina, jolloin kutakin
logikirjastoa käyttävä abstraktin luokan implementaatio määrittelee kirjastoon nojaavan
rajapintansa itse.

\newthought{Rajapintaluokkien tehtävä} puolestaan on yleensä luoda pieniä, selkeitä
toiminnallisuussopimuksia koodissa. Mikäli myöhemmin ilmenee tarve lisätä johonkin luokkaan jo
valmiiksi määritellyn rajapinnan toiminnallisuudet, voidaan luokan määritelmään lisätä tämä
rajapinta \java{implements}-avainsanalla. Esimerkiksi pelinkehityksessä saatetaan tarvita
tuhoutuvia objekteja, joita varten voitaisiin luoda "Destructable"-rajapintaluokka jolle on
määritelty "destroyObject"-metodi. Koodi voi sitten tarkistaa implementoiko jokin luokka tämä
rajapinnan \newjava{instanceof}-avainsanalla ja jos luokka implementoi "Destructable"-rajapinnan,
koodi voi kutsua "destroyObject"-metodia luokan instanssista tuhoten objektin.

\newthought{Rajapintaluokan ja} abstraktin luokan käyttötarkoitukset siis eroavat toisistaan
hieman. Yleisesti rajapintaluokan tehtävä on määrittää laajemmin käytössä oleva sopimus, joka
voidaan implementoida eri kohdissa koodia eri luokille. Tästä hyvä esimerkki on
\nameref{serialisaatio}-kappaleessa käsiteltävä \java{Serializable}-rajapintaluokka. Abstrakti
luokka taas määrittää yhden toiminnallisuudeltaan rajatun luokkatyypin, mutta antaa tämän
toiminnallisuuden toteutusvastuun eteenpäin kantaluokan lapsiluokille. Mahtava esimerkki tästä
ovat Minecraft-pelin kuutiot. Jokainen kuutiotyyppi on abstraktin "Block"-luokan konkreettinen
lapsiluokka, joka määrittää yksittäisen kuutiotyypin tarkemmat toiminnallisuudet.

\newthought{Samaan tapaan} oppaan koodiesimerkeissä kappaleissa \nameref{abstract} ja
\nameref{interface} abstraktin luokan esimerkissä hyödynnetään abstraktin kantaluokan kykyä
määritellä konkreettisia metodeja kantaluokkaan: oletettavasti kaikki lapsiluokat hyödyntävät
"formatLogString"-metodia. Rajapintaluokkaesimerkissä puolestaan luotu "TextProvider"-rajapinta
on vain yksinkertainen rajapinta, jonka mikä tahansa ohjelmiston luokka saattaa toteuttaa
tarvittaessa. Abstraktilla luokalla on yksi suunniteltu käyttötarkoitus, jonka toteutustapa
määritellään lapsiluokan implementaatiossa, kun taas rajapintaluokan käyttötarkoitus ei ole niin
tarkkaan rajattu ja rajapintaa voidaan implementoida useammassa paikassa koodissa.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Serialisaatio}
\label{serialisaatio}

\newthought{Javassa ohjelmiston} omistama data on yleensä tallennettu oliomuodossa, mutta olion
tallentaminen tiedostoon tekstidatana ei ole erityisen helppoa. Se vaatisi kaikkien olion kenttien
muuttamista tekstiksi manuaalisesti aina oliota tallennettaessa ja tekstimuotoisen datan lukemista
ja uuden olion rakentamista luetusta tekstidatasta aina oliota ladattaessa. Tähän tarkoitukseen
Javasta löytyy erikseen \gls{serialisaatio}-niminen tekniikka, joka mahdollistaa olioiden
automaattisen muuttamisen tallennettavaan muotoon ja tämän muodon muuttamisen takaisin olioksi.

\newthought{Serialisaatio on} mahdollista vain luokille, jotka implementoivat
\newjava{Serializable}-rajapinnan. Tämän lisäksi kaikkien luokan muuttujien on myös oltava
tietotyyppiä, joka implementoi tämän rajapinnan. Suurimmaksi osaksi tämä koskee vain käyttäjän
määrittelemiä luokkia, sillä kaikki primitiiviset tietotyypit ja suurin osa standardikirjaston
yleisesti käytetyistä luokista, kuten kokoelmat, implementoivat \java{Serializable}-rajapinnan.

\newthought{Jos luokka} ja kaikki luokan muuttujat implementoivat \java{Serializable}-rajapinnan,
voidaan luokan instanssi muuttaa tekstimuotoon \newjava{ObjectOutputStream}-luokan avulla.
Luokan julkinen rakentaja ottaa \java{OutputStream}-olion, joka edustaa datakuluttajaa, johon
serialisoitava objekti kirjoitetaan. Luodusta instanssista voidaan kutsua instanssin writeObject-
metodia serialisoitavalla oliolla. Tämä kirjoitaa olion serialisoidun tavudataversion
\java{ObjectOutputStream}-rakentajassa määriteltyyn \java{OutputStream}-olioon.

\newthought{Luokan deserialisaatio} tapahtuu \newjava{ObjectInputStream}-luokan avulla. Luokan
julkinen rakentaja ottaa \java{InputStream}-olion, joka edustaa datasyötettä, josta
deserialisoitava objekti on luettavissa. Luodusta instassista voidaan kutsua instanssin
readObject-metodia ilman argumentteja. Tämä palauttaa deserialisoidun olion luetun tavudatan
pohjalta.

\newthought{Seuraava koodiesimerkki} esittelee serialisoitavan luokan luomisen, serialisaation
tiedostoon ja deserialisaation tiedostosta. Huomioi, että mikäli serialisoituja olioita
tallennetaan tiedostoon, on normaalia nimetä tiedosto ".ser"-päätteellä.

\code{week6/serializationexample}{SerializableData}{Serialisoitava luokka}
\code{week6/serializationexample}{Main}{Serialisaatioesimerkin pääluokka}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Singleton-suunnittelumalli}
\label{singletonkappale}

\newthought{Välillä ohjelmistoa} luodessa on tarve luoda luokka, josta on olemassa vain yksi
instanssi, jota muu ohjelma voi kutsua tarvittaessa. Tähän käyttötarkoitukseen on kehitettu
suunnittelumalli nimeltä \neweng{singleton}{singleton}. Suunnittelumallin ideana on tallentaa
luokan instanssi yksityiseen luokkamuuttujaan ja tarjota julkinen "getInstance"-luokkametodi,
joka joko hakee olemassaolevan instanssin luokkamuuttujasta tai luo uuden instanssin
luokkamuuttujaan, mikäli instanssia ei vielä ole olemassa. Seuraava koodiesimerkki esittelee
tämän toteutuksen käytännössä.

\code{week8/singletonexample}{SimpleSingleton}{Singleton-suunnittelumallin toteuttava luokka}

\newthought{\Gls{singleton}-suunnittelumallia} on kritisoitu, sillä se luo ohjelmistolle jaetun
julkisen tilan toimien käytännössä glorifioituna globaalina muuttujana. Mallille on kuitenkin
olemassa selkeitä hyödyllisiä käyttökohteita, kuten tietokantayhteyden standardointi. Nämä
käyttökohteet ovat yleensä jaettuja palveluita, jotka ovat joko lähes tai täysin tilattomia.
Vahvasti tilallisen olion tallentaminen singleton-luokkaan on valtava virheriski, koska olioon
pääse käsiksi mistä tahansa koodissa ja siten sen tila on erittäin helppo muuttaa epähuomiossa
virheelliseksi.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{SOLID-periaatteet, käyttäjän määrittelemät virheluokat}
\label{solid+exceptions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SOLID-periaatteet}
\label{solid}

\newthought{Tässä vaiheessa} opasta oppaan käyttäjä osaa jo toivottavasti tuottaa toimivaa
oliopohjaista koodia. Ikävä kyllä toimiva koodi ei tarkoita suoraan laadukasta koodia. Laadukas
koodi on uusiokäytettävää, helppolukuista ja laajennettavaa. Yksi laadukkaan koodin tuottamista
helpottamaan kehitetty menetelmä ovat \neweng{SOLID-periaatteet}{SOLID-principles}. Periaatteet
eivät ole kiveen hakattuja, mutta niiden noudattaminen tuottaa yleensä vähintään kohtalaisen
laadukasta koodia. Periaatteita on viisi: \neweng{yhden vastuun periaate}{Single Responsibility
Principle}, \neweng{avoin/suljettu-periaate}{Open Closed Principle}, aiemmin käsitelty
\gls{Liskovin korvaavuusperiaate} (kappale \nameref{LSP}), \neweng{rajapintojen erottelu
-periaate}{Interface Segregation Principle} ja \neweng{kaanteisten riippuvuuksien periaate}
{Dependency Inversion Principle}. SOLID-lyhenne syntyy periaatteiden englanninkielisten nimien
ensimmäisistä kirjaimista. Periaatteiden seuraaminen ei ole pakollista, mutta se yleensä helpottaa
koko ohjelmointiprosessia pidemmällä aikavälillä.

\subsection{Yhden vastuun periaate}
\label{SRP}

\newthought{Ensimmäinen periaate} on \gls{yhden vastuun periaate}. Se käsittelee luokkien
suunnittelua ja käyttöä. Periaatteen mukaan jokaisella luokalla pitäisi olla yksi, ja vain yksi
vastuu. Mikäli luokan käyttötarkoitus ei ole kuvailtavissa yhdellä melko yksinkertaisella
lauseella, rikkoo luokka todennäköisesti yhden vastuun periaatetta.

\subsection{Avoin/suljettu-periaate}
\label{OCP}

\newthought{Toinen SOLID-periaate} on \gls{avoin/suljettu-periaate}. Sen mukaan ohjelmiston
koodin tulisi olla avoin laajennuksille, mutta suljettu muutoksille. Käytännössä tämä tarkoittaa,
että toteutettujen toiminnallisuuksien koodin tulisi olla suunniteltu olettaen, että sama koodi
säilyy ohjelmistossa koko sen elinkaaren läpi. Toisaalta taas koodin tulisi olla helposti
laajennettavissa. Käytännössä periaatteen tavoitteena on rohkaista suunnittelemaan ohjelmistoja
niin, että ensisijainen tapa lisätä toiminnallisuuksia ei olisi vanhojen luokkien muokkaaminen,
vaan uusien lisääminen.

\newthought{Käytännössä esimerkiksi} \java{switch}-rakenteiden käyttö monesti rikkoo 
avoin/suljettu periaatetta. Mikäli rakenteeseen tarvitsee lisätä uusi haara, täytyy ohjelmoijan
käydä muokkaamassa vanhaa koodia, mikä altistaa ohjelmiston virhetiloille, kun kertaalleen
toimivaksi todettua koodia muokataan myöhemmin. Oliopohjaisessa ohjelmoinnissa kannustetaan
korvaamaan switch rakenteet \neweng{strategia}{strategy}-suunnittelumallilla. Seuraava
koodiesimerkki havainnollistaa saman rakenteen toteuttamisen enum-switch yhdistelmällä, ja
strategia-suunnittelumallilla. Huomaa, kuinka paljon helpompaa jälkimmäisen laajentaminen on,
rakenteen sisäistä koodia ei tarvitse muuttaa ollenkaan, vaikka esimerkkiin lisättäisiin
väli-ilmansuunnat tai muita suuntia. Jokainen suuntaluokka voisi määritellä hahmon liikkeen
omassa movePlayer-metodissaan. Sen sijaan ensimmäisen esimerkin laajentaminen vaatii jo valmiin
koodin muokkaamista aina, kun rakenteeseen halutaan lisätä uusi suunta.

\code{week9/openclosedexample}{Player}{Pelaaja-luokka, jonka koordinaatteja esimerkissä pyritään
muuttamaan}
\code{week3/enumexample}{CompassPoint}{Ilmansuunnat \java{enum}-luokalla esiteltynä}
\code{week9/openclosedexample}{MoveSwitch}{Hahmon liikuttaminen \java{switch}-rakenteella ja
ilmansuuntia esittävällä \java{enum}-rakenteella}
\code{week9/openclosedexample}{MovementCommand}{Rajapintaluokka hahmon liikkuttamiseen
\gls{strategia}-suunnittelumallilla}
\code{week9/openclosedexample}{MoveNorth}{Liikkumiskomento pohjoiseen}
\code{week9/openclosedexample}{MoveEast}{Liikkumiskomento itään}
\code{week9/openclosedexample}{MoveSouth}{Liikkumiskomento etelään}
\code{week9/openclosedexample}{MoveWest}{Liikkumiskomento länteen}
\code{week9/openclosedexample}{MoveStrategy}{Hahmon liikuttaminen 
\gls{strategia}-suunnittelumallilla}

\subsection{Rajapintojen erottelu -periaate}
\label{ISP}

\newthought{SOLID-periaatteista} neljäs on \gls{rajapintojen erottelu -periaate}. Se käsittelee
rajapintaluokkien käyttöä ja luokkien kokoa. Periaatteen mukaan, jos luokka implementoi
rajapintaluokan, täytyisi luokan tarvita kaikkia rajapinnan metodeja. Rajapintaluokkien pitäisi
olla siis tarpeeksi hyvin rajattuja, jotta niiden kaikki metodit kuuluvat yhteen
toiminnallisuuspakettiin. Periaate kannustaa siis luomaan monta pientä rajapintaa ja
implementoimaan niistä tarvittavat yhden valtavan rajapinnan sijaan. Tämä helpottaa jo luotujen
rajapintaluokkien uudelleenkäyttöä.

\subsection{Käänteisten riippuvuuksien periaate}
\label{DIP}

\newthought{Viimeinen on} SOLID-periaate on \gls{kaanteisten riippuvuuksien periaate}. Se
käsittelee riippuvuuksien suuntaa ohjelmistossa. Periaate perustuu toiveeseen korkean
abstraktiotason komponenttien uusiokäytöstä ja vastustuskyvystä muutoksille. Molemmat ominaisuudet
vaativat, että kyseiset komponentit eivät ole suoraan riippuvaisia käyttämistään alemman tason
komponenteista. Periaate on yleensä esitetty kahtena perusideana:

\begin{enumerate}
	\item Korkean tason komponenttien ei pitäisi olla riippuvaisia matalan tason komponenteista. Molempien pitäisi olla riippuvaisia abstraktioista.
	\item Abstraktioiden ei pitäisi olla riippuvaisia yksityiskohdista. Yksityiskohtien pitäisi olla riippuvaisia abstraktioista.
\end{enumerate}

\newthought{Käytännössä tämä} tarkoittaa, että seuratakseen käänteisten riippuvuuksien periaatetta
korkean tason luokka ei saa luoda itse tarvitsemiaan alemman tason riippuvuuksia, vaan sen on
pyydettävä ne muulta ohjelmistolta rakentajassaan. Täten täytetään ensimmäisen säännön ensimmäinen
puoli. Säännön toinen puoli puolestaan täyttyy, kun korkean tason komponentti ei pyydä
rakentajassaan konkreettista luokkaa riippuvuutena, vaan rajapintaluokkaa, jonka alemman tason
komponentti toteuttaa. Seuraava kuvapari havainnollistaa tämän suorat riippuvuudet rikkovan
arkkitehtuurin \gls{UML}-luokkakaaviona. Huomaa HighLevelService-luokan assosiaationuolen tyypin
muuttuminen. Ensimmäisessä kuvassa luokkien välinen suhde on \gls{kompositio}, kun taas toisessa
suhteen tyyppi on \gls{aggregaatio}. Tämä johtuu teoreettisesta LowLevelServiceInterface-luokan
vastaanottamisesta luokan rakentajassa konkreettisen LowLevelService luokan luonnin sijaan.
Täten LowLevelServiceInterface luokan elinikä ei enää ole sidottu HighLevelService-luokan
elinikään.

\begin{listing}
    \includegraphics{NoDIPExample}
    \caption{Luokkakaavio suorasta riippuvuudesta korkean ja matalan tason luokan välillä}
    \label{luokkakaavioluokka}
\end{listing}

\begin{listing}
    \includegraphics{DIPExample}
    \caption{Luokkakaavio rajapintaluokalla piilotetusta riippuvuudesta korkean ja matalan tason luokan välillä}
    \label{luokkakaavioluokka}
\end{listing}

\newthought{Käänteisten riippuvuuksien} periaatteeseen sitoutuminen tuottaa yleensä jonkin verran
ylimääräistä koodia riippuvuuskohtien rajapintojen luonnissa. Lisäksi ohjelmistoon on luotava
luokka tai luokkia, joiden vastuulla on ohjelmiston riippuvuuksien rakentaminen käynnistyksen
yhteydessä, koska korkean tason luokat eivät enää osaa itse rakentaa tarvitsemiaan matalan tason
palveluita. Periaate saattaa vaikuttaa turhalta teoreettiselta näpertelyltä ja sitä se
todennäköisesti onkin pienemmissä projekteissa. Periaatteella on kuitenkin valtava jalansija
teollisessa koodintuotannossa, eikä tämä ole sattumaa. Käänteisten riippuvuuksien periaatetta
noudattavaa koodia on uskomattoman helppo testata, koska jokainen palvelu voidaan irrottaa lopun
ohjelmiston kontekstista ja palvelua voidaan testata puhtaasti oman toiminnallisuutensa suhteen.
Opas ei siis suosittele kaikkia oppaan lukijoita toteuttamaan omia projektejaan käänneteisten
riippuvuuksien periaatteen mukaan. Periaate kannattaa kuitenkin opetella, sillä siirryttäessä
työelämään koodikantojen koko ja testaamisen merkitys molemmat moninkertaistuvat ja silloin
käänteisten riippuvuuksien periaate kohoaa todennäköisesti tärkeimmäksi kaikista 
SOLID-periaatteista.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Käyttäjän määrittelemät virhetilat}
\label{exception}

\newthought{Aiemmin oppaan} luvussa \nameref{try-catch} käytiin läpi Javan
virhetilanhallintasyntaksi. Luvussa käsiteltiin standardikirjaston toimintojen aiheuttamia
virhetiloja, mutta standardikirjaston ei omista yksinoikeutta virhetilojen aiheuttamiseen.
Käyttäjä itse voi myös nostaa ja jopa luoda uusia virhetilaluokkia. Virhetilaluokka nostetaan
\newjava{throw}-avainsanalla ja käyttäjä voi luoda omia virhetilaluokkiaan periyttämällä luokan
\newjava{Exception}-luokasta.

\subsection{Käyttäjän määrittelemä virhetilaluokka}
\label{exception}

\newthought{Ohjelmistolla voi} olla monia syitä käyttää käyttäjän itse määrittelemiä virhetiloja.
Perimmäinen syy virhetilalle on aina mahdollistaa jostakin ajonaikaisesta ongelmasta toipuminen.
Java tarjoaa virhetilaluokat laitteiston ja standardikirjaston toiminnasta riippuville ongelmille,
mutta se ei pysty tarjoamaan ohjelmiston suunnittelusta aiheutuville mahdollisille ongelmille
erikseen määriteltyjä virheitä. Esimerkiksi virheellinen käyttäjäsyöte voi aiheuttaa tilanteen,
jossa ohjelman ajoa ei voida jatkaa normaalisti. Tätä varten Java tarjoaa käyttäjälle
mahdollisuuden luoda omia virhetilaluokkiaan. Tämä tapahtuu yksinkertaisesti periyttämällä
toivotun virhetilaluokan \java{Exception}-luokasta.

\subsection{Manuaalinen virhetilan aiheuttaminen}
\label{throws}

\newthought{Oman virhetilaluokan} luominen ei hyödytä ohjelmistoa, ellei ohjelmointikieli tarjoa
työkaluja käyttää luotua virhetilaluokkaa. Tätä varten Java tarjoaa \java{throw}-avainsanan.
Avainsanaa käytetään lisäämällä avainsanan perään jonkin virhetilan instanssi, tai luomalla uusi
virhetilaluokan instanssi \java{new}-avainsanalla. Tämä aiheuttaa koodin siirtymisen
virhetilanhallintaan, josta aiheutettu virhetila voidaan hallitusti napata ylemmällä tasolla. Tämä
mahdollistaa siistin virhetilasta palautumisen tasolla, jossa se on mahdollista. 

\newthought{Pelkkä virhetilan} nosto ei kuitenkaan riitä, mikäli virhetilan palautuminen ei
tapahdu saman metodin sisällä. Java vaatii käyttäjää määrittelemään metodit, jotka voivat
aiheuttaa käsittelemättömiä virhetiloja \newjava{throws}-avainsanalla. Avainsana lisätään metodin
määritelmään nimen ja parametrien jälkeen ja avainsanan perään lisätään virhetilaluokka tai 
-luokat, joita metodi saattaa aiheuttaa. Javan kääntäjä vaatii käyttäjää käsittelemään kaikki
virhetilat jota kutsuttu metodi voi aiheuttaa. Tämän vaatimuksen voi kiertää määrittelemällä
metodin, joka kutsuu virhetilan aiheuttavaa metodia, myös kyseisen virhetilan aiheuttavaksi. Tämä
siirtää vastuun virhetilan käsittelystä yhtä kooditasoa ylemmäksi. Yleensä virhetilat kannattaa
kuitenkin käsitellä alimmalla tasolla, jolla puhdas palautuminen virhetilasta on mahdollista.

\newthought{Seuraava koodiesimerkki} esittelee käyttäjän määrittelemän virhetilaluokan luomisen,
sekä virhetilan aiheuttavan metodin määrittelemisen. Virhetila johtuu käyttäjän virheellisestä
syötteestä, joten se käsitellään alimalla tasolla, jolla täydellinen toipuminen on mahdollista:
käyttäjärajapinnassa.

\code{week9/exceptionexample}{NoDatabaseEntyException}{Itse määritelty virhetilaluokka}
\code{week9/exceptionexample}{DatabaseConnection}{Yksinkertaistettu tietokantayhteyttä matkiva
luokka, joka nostaa luodun virhetilan jos annettua esinettä ei löydy}
\code{week9/exceptionexample}{Main}{Pääluokka, joka kutsuu luotua valetietokantaa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\printglossary[title=Sanasto, toctitle=Sanasto]
\printglossary[type=java, title=Javan avainsanat, toctitle=Javan avainsanat]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
